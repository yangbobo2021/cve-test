{
    "before_functions": "def validate_signed_elements\n  signature_nodes = REXML::XPath.match(\n    decrypted_document.nil? ? document : decrypted_document,\n    \"//ds:Signature\",\n    {\"ds\"=>DSIG}\n  )\n  signed_elements = []\n  signature_nodes.each do |signature_node|\n    signed_element = signature_node.parent.name\n    if signed_element != 'Response' && signed_element != 'Assertion'\n      return append_error(\"Found an unexpected Signature Element. SAML Response rejected\")\n    end\n    signed_elements << signed_element\n  end\n\n  unless signature_nodes.length < 3 && !signed_elements.empty?\n    return append_error(\"Found an unexpected number of Signature Element. SAML Response rejected\")\n  end\n\n  if settings.security[:want_assertions_signed] && !(signed_elements.include? \"Assertion\")\n    return append_error(\"The Assertion of the Response is not signed and the SP requires it\")\n  end\n\n  true\nend\n\ndef validate_structure\n  unless valid_saml?(document, soft)\n    return append_error(\"Invalid SAML Response. Not match the saml-schema-protocol-2.0.xsd\")\n  end\n\n  true\nend\n\ndef validate_signature\n  error_msg = \"Invalid Signature on SAML Response\"\n\n  # If the response contains the signature, and the assertion was encrypted, validate the original SAML Response\n  # otherwise, review if the decrypted assertion contains a signature\n  sig_elements = REXML::XPath.match(\n    document,\n    \"/p:Response/ds:Signature]\",\n    { \"p\" => PROTOCOL, \"ds\" => DSIG }\n  )\n\n  use_original = sig_elements.size == 1 || decrypted_document.nil?\n  doc = use_original ? document : decrypted_document\n\n  # Check signature nodes\n  if sig_elements.nil? || sig_elements.size == 0\n    sig_elements = REXML::XPath.match(\n      doc,\n      \"/p:Response/a:Assertion/ds:Signature\",\n      {\"p\" => PROTOCOL, \"a\" => ASSERTION, \"ds\"=>DSIG}\n    )\n  end\n\n  if sig_elements.size != 1\n    return append_error(error_msg)\n  end\n\n  opts = {}\n  opts[:fingerprint_alg] = settings.idp_cert_fingerprint_algorithm\n  opts[:cert] = settings.get_idp_cert\n  fingerprint = settings.get_fingerprint\n\n  unless fingerprint && doc.validate_document(fingerprint, @soft, opts)          \n    return append_error(error_msg)\n  end\n\n  true\nend\n",
    "after_functions": "def validate_signed_elements\n  signature_nodes = REXML::XPath.match(\n    decrypted_document.nil? ? document : decrypted_document,\n    \"//ds:Signature\",\n    {\"ds\"=>DSIG}\n  )\n  signed_elements = []\n  seis = []\n  ids = []\n  signature_nodes.each do |signature_node|\n    signed_element = signature_node.parent.name\n    if signed_element != 'Response' && signed_element != 'Assertion'\n      return append_error(\"Found an unexpected Signature Element. SAML Response rejected\")\n    end\n\n    if signature_node.parent.attributes['ID'].nil?\n      return append_error(\"Signed Element must contain ID. SAML Response rejected\")\n    end\n\n    id = signature_node.parent.attributes.get_attribute(\"ID\").value\n    if ids.include?(id)\n      return append_error(\"Duplicated ID. SAML Response rejected\")\n    end\n    ids.push(id)\n\n    # Check that reference URI matches the parent ID and no duplicate References or IDs\n    ref = REXML::XPath.first(signature_node, \".//ds:Reference\", {\"ds\"=>DSIG})\n    if ref\n      uri = ref.attributes.get_attribute(\"URI\")\n      if uri && !uri.value.empty?\n        sei = uri.value[1..-1]\n        id = signature_node.parent.attributes.get_attribute(\"ID\").value\n\n        unless sei == id\n          return append_error(\"Found an invalid Signed Element. SAML Response rejected\")\n        end\n\n        if seis.include?(sei)\n          return append_error(\"Duplicated Reference URI. SAML Response rejected\")\n        end\n\n        seis.push(sei)\n      end\n    end\n\n    signed_elements << signed_element\n  end\n\n  unless signature_nodes.length < 3 && !signed_elements.empty?\n    return append_error(\"Found an unexpected number of Signature Element. SAML Response rejected\")\n  end\n\n  if settings.security[:want_assertions_signed] && !(signed_elements.include? \"Assertion\")\n    return append_error(\"The Assertion of the Response is not signed and the SP requires it\")\n  end\n\n  true\nend\n\ndef validate_structure\n  structure_error_msg = \"Invalid SAML Response. Not match the saml-schema-protocol-2.0.xsd\"\n  unless valid_saml?(document, soft)\n    return append_error(structure_error_msg)\n  end\n\n  unless decrypted_document.nil?\n    unless valid_saml?(decrypted_document, soft)\n      return append_error(structure_error_msg)\n    end\n  end\n\n  true\nend\n\ndef validate_signature\n  error_msg = \"Invalid Signature on SAML Response\"\n\n  # If the response contains the signature, and the assertion was encrypted, validate the original SAML Response\n  # otherwise, review if the decrypted assertion contains a signature\n  sig_elements = REXML::XPath.match(\n    document,\n    \"/p:Response[@ID=$id]/ds:Signature]\",\n    { \"p\" => PROTOCOL, \"ds\" => DSIG },\n    { 'id' => document.signed_element_id }\n  )\n\n  use_original = sig_elements.size == 1 || decrypted_document.nil?\n  doc = use_original ? document : decrypted_document\n\n  # Check signature nodes\n  if sig_elements.nil? || sig_elements.size == 0\n    sig_elements = REXML::XPath.match(\n      doc,\n      \"/p:Response/a:Assertion[@ID=$id]/ds:Signature\",\n      {\"p\" => PROTOCOL, \"a\" => ASSERTION, \"ds\"=>DSIG},\n      { 'id' => doc.signed_element_id }\n    )\n  end\n\n  if sig_elements.size != 1\n    return append_error(error_msg)\n  end\n\n  opts = {}\n  opts[:fingerprint_alg] = settings.idp_cert_fingerprint_algorithm\n  opts[:cert] = settings.get_idp_cert\n  fingerprint = settings.get_fingerprint\n\n  unless fingerprint && doc.validate_document(fingerprint, @soft, opts)          \n    return append_error(error_msg)\n  end\n\n  true\nend\n"
}