{
    "before_functions": "def make_environ(self):\n    request_url = url_parse(self.path)\n\n    def shutdown_server():\n        self.server.shutdown_signal = True\n\n    url_scheme = self.server.ssl_context is None and 'http' or 'https'\n    path_info = url_unquote(request_url.path)\n\n    environ = {\n        'wsgi.version':         (1, 0),\n        'wsgi.url_scheme':      url_scheme,\n        'wsgi.input':           self.rfile,\n        'wsgi.errors':          sys.stderr,\n        'wsgi.multithread':     self.server.multithread,\n        'wsgi.multiprocess':    self.server.multiprocess,\n        'wsgi.run_once':        False,\n        'werkzeug.server.shutdown': shutdown_server,\n        'SERVER_SOFTWARE':      self.server_version,\n        'REQUEST_METHOD':       self.command,\n        'SCRIPT_NAME':          '',\n        'PATH_INFO':            wsgi_encoding_dance(path_info),\n        'QUERY_STRING':         wsgi_encoding_dance(request_url.query),\n        'CONTENT_TYPE':         self.headers.get('Content-Type', ''),\n        'CONTENT_LENGTH':       self.headers.get('Content-Length', ''),\n        'REMOTE_ADDR':          self.address_string(),\n        'REMOTE_PORT':          self.port_integer(),\n        'SERVER_NAME':          self.server.server_address[0],\n        'SERVER_PORT':          str(self.server.server_address[1]),\n        'SERVER_PROTOCOL':      self.request_version\n    }\n\n    for key, value in self.headers.items():\n        key = 'HTTP_' + key.upper().replace('-', '_')\n        if key not in ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH'):\n            environ[key] = value\n\n    if request_url.netloc:\n        environ['HTTP_HOST'] = request_url.netloc\n\n    return environ\n",
    "after_functions": "def make_environ(self):\n    request_url = url_parse(self.path)\n\n    def shutdown_server():\n        self.server.shutdown_signal = True\n\n    url_scheme = self.server.ssl_context is None and 'http' or 'https'\n    path_info = url_unquote(request_url.path)\n\n    environ = {\n        'wsgi.version':         (1, 0),\n        'wsgi.url_scheme':      url_scheme,\n        'wsgi.input':           self.rfile,\n        'wsgi.errors':          sys.stderr,\n        'wsgi.multithread':     self.server.multithread,\n        'wsgi.multiprocess':    self.server.multiprocess,\n        'wsgi.run_once':        False,\n        'werkzeug.server.shutdown': shutdown_server,\n        'SERVER_SOFTWARE':      self.server_version,\n        'REQUEST_METHOD':       self.command,\n        'SCRIPT_NAME':          '',\n        'PATH_INFO':            wsgi_encoding_dance(path_info),\n        'QUERY_STRING':         wsgi_encoding_dance(request_url.query),\n        'CONTENT_TYPE':         self.headers.get('Content-Type', ''),\n        'CONTENT_LENGTH':       self.headers.get('Content-Length', ''),\n        'REMOTE_ADDR':          self.address_string(),\n        'REMOTE_PORT':          self.port_integer(),\n        'SERVER_NAME':          self.server.server_address[0],\n        'SERVER_PORT':          str(self.server.server_address[1]),\n        'SERVER_PROTOCOL':      self.request_version\n    }\n\n    for key, value in self.headers.items():\n        key = 'HTTP_' + key.upper().replace('-', '_')\n        if key not in ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH'):\n            environ[key] = value\n\n    if request_url.scheme and request_url.netloc:\n        environ['HTTP_HOST'] = request_url.netloc\n\n    return environ\n"
}