{
    "before_functions": "createExtractor(\n  resolve: (fetched: FetchedOverride) => void,\n  reject: (error: Error) => void,\n  tarballPath?: string,\n): {\n  hashValidateStream: stream.PassThrough,\n  integrityValidateStream: stream.PassThrough,\n  extractorStream: stream.Transform,\n} {\n  const hashInfo = this._supportedIntegrity({hashOnly: true});\n  const integrityInfo = this._supportedIntegrity({hashOnly: false});\n\n  const now = new Date();\n\n  const fs = require('fs');\n  const patchedFs = Object.assign({}, fs, {\n    utimes: (path, atime, mtime, cb) => {\n      fs.stat(path, (err, stat) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        if (stat.isDirectory()) {\n          fs.utimes(path, atime, mtime, cb);\n          return;\n        }\n        fs.open(path, 'a', (err, fd) => {\n          if (err) {\n            cb(err);\n            return;\n          }\n          fs.futimes(fd, atime, mtime, err => {\n            if (err) {\n              fs.close(fd, () => cb(err));\n            } else {\n              fs.close(fd, err => cb(err));\n            }\n          });\n        });\n      });\n    },\n  });\n\n  const hashValidateStream = new ssri.integrityStream(hashInfo);\n  const integrityValidateStream = new ssri.integrityStream(integrityInfo);\n\n  const untarStream = tarFs.extract(this.dest, {\n    strip: 1,\n    dmode: 0o755, // all dirs should be readable\n    fmode: 0o644, // all files should be readable\n    chown: false, // don't chown. just leave as it is\n    map: header => {\n      header.mtime = now;\n      return header;\n    },\n    fs: patchedFs,\n  });\n  const extractorStream = gunzip();\n\n  hashValidateStream.once('error', err => {\n    this.validateError = err;\n  });\n  integrityValidateStream.once('error', err => {\n    this.validateError = err;\n  });\n  integrityValidateStream.once('integrity', sri => {\n    this.validateIntegrity = sri;\n  });\n\n  untarStream.on('error', err => {\n    reject(new MessageError(this.config.reporter.lang('errorExtractingTarball', err.message, tarballPath)));\n  });\n\n  extractorStream.pipe(untarStream).on('finish', () => {\n    const error = this.validateError;\n    const hexDigest = this.validateIntegrity ? this.validateIntegrity.hexDigest() : '';\n    if (\n      this.config.updateChecksums &&\n      this.remote.integrity &&\n      this.validateIntegrity &&\n      this.remote.integrity !== this.validateIntegrity.toString()\n    ) {\n      this.remote.integrity = this.validateIntegrity.toString();\n    } else if (this.validateIntegrity) {\n      this.remote.cacheIntegrity = this.validateIntegrity.toString();\n    }\n\n    if (integrityInfo.integrity && Object.keys(integrityInfo.integrity).length === 0) {\n      return reject(\n        new SecurityError(\n          this.config.reporter.lang('fetchBadIntegrityAlgorithm', this.packageName, this.remote.reference),\n        ),\n      );\n    }\n\n    if (error) {\n      if (this.config.updateChecksums) {\n        this.remote.integrity = error.found.toString();\n      } else {\n        return reject(\n          new SecurityError(\n            this.config.reporter.lang(\n              'fetchBadHashWithPath',\n              this.packageName,\n              this.remote.reference,\n              error.found.toString(),\n              error.expected.toString(),\n            ),\n          ),\n        );\n      }\n    }\n\n    return resolve({\n      hash: this.hash || hexDigest,\n    });\n  });\n\n  return {hashValidateStream, integrityValidateStream, extractorStream};\n}\n",
    "after_functions": "createExtractor(\n  resolve: (fetched: FetchedOverride) => void,\n  reject: (error: Error) => void,\n  tarballPath?: string,\n): {\n  hashValidateStream: stream.PassThrough,\n  integrityValidateStream: stream.PassThrough,\n  extractorStream: stream.Transform,\n} {\n  const hashInfo = this._supportedIntegrity({hashOnly: true});\n  const integrityInfo = this._supportedIntegrity({hashOnly: false});\n\n  const now = new Date();\n\n  const fs = require('fs');\n  const patchedFs = Object.assign({}, fs, {\n    utimes: (path, atime, mtime, cb) => {\n      fs.stat(path, (err, stat) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        if (stat.isDirectory()) {\n          fs.utimes(path, atime, mtime, cb);\n          return;\n        }\n        fs.open(path, 'a', (err, fd) => {\n          if (err) {\n            cb(err);\n            return;\n          }\n          fs.futimes(fd, atime, mtime, err => {\n            if (err) {\n              fs.close(fd, () => cb(err));\n            } else {\n              fs.close(fd, err => cb(err));\n            }\n          });\n        });\n      });\n    },\n  });\n\n  const hashValidateStream = new ssri.integrityStream(hashInfo);\n  const integrityValidateStream = new ssri.integrityStream(integrityInfo);\n\n  const untarStream = tarFs.extract(this.dest, {\n    strip: 1,\n    dmode: 0o755, // all dirs should be readable\n    fmode: 0o644, // all files should be readable\n    chown: false, // don't chown. just leave as it is\n    map: header => {\n      header.mtime = now;\n      if (header.linkname) {\n        const basePath = path.posix.dirname(path.join('/', header.name));\n        const jailPath = path.posix.join(basePath, header.linkname);\n        header.linkname = path.posix.relative('/', jailPath);\n      }\n      return header;\n    },\n    fs: patchedFs,\n  });\n  const extractorStream = gunzip();\n\n  hashValidateStream.once('error', err => {\n    this.validateError = err;\n  });\n  integrityValidateStream.once('error', err => {\n    this.validateError = err;\n  });\n  integrityValidateStream.once('integrity', sri => {\n    this.validateIntegrity = sri;\n  });\n\n  untarStream.on('error', err => {\n    reject(new MessageError(this.config.reporter.lang('errorExtractingTarball', err.message, tarballPath)));\n  });\n\n  extractorStream.pipe(untarStream).on('finish', () => {\n    const error = this.validateError;\n    const hexDigest = this.validateIntegrity ? this.validateIntegrity.hexDigest() : '';\n    if (\n      this.config.updateChecksums &&\n      this.remote.integrity &&\n      this.validateIntegrity &&\n      this.remote.integrity !== this.validateIntegrity.toString()\n    ) {\n      this.remote.integrity = this.validateIntegrity.toString();\n    } else if (this.validateIntegrity) {\n      this.remote.cacheIntegrity = this.validateIntegrity.toString();\n    }\n\n    if (integrityInfo.integrity && Object.keys(integrityInfo.integrity).length === 0) {\n      return reject(\n        new SecurityError(\n          this.config.reporter.lang('fetchBadIntegrityAlgorithm', this.packageName, this.remote.reference),\n        ),\n      );\n    }\n\n    if (error) {\n      if (this.config.updateChecksums) {\n        this.remote.integrity = error.found.toString();\n      } else {\n        return reject(\n          new SecurityError(\n            this.config.reporter.lang(\n              'fetchBadHashWithPath',\n              this.packageName,\n              this.remote.reference,\n              error.found.toString(),\n              error.expected.toString(),\n            ),\n          ),\n        );\n      }\n    }\n\n    return resolve({\n      hash: this.hash || hexDigest,\n    });\n  });\n\n  return {hashValidateStream, integrityValidateStream, extractorStream};\n}\n"
}