{
    "before_functions": "private static boolean checkPermissionOfOther(FileSystem fs, Path path,\n    FsAction action, Map<URI, FileStatus> statCache) throws IOException {\n  FileStatus status = getFileStatus(fs, path.toUri(), statCache);\n  FsPermission perms = status.getPermission();\n  FsAction otherAction = perms.getOtherAction();\n  if (otherAction.implies(action)) {\n    return true;\n  }\n  return false;\n}\n",
    "after_functions": "private static boolean checkPermissionOfOther(FileSystem fs, Path path,\n    FsAction action, Map<URI, FileStatus> statCache) throws IOException {\n  FileStatus status = getFileStatus(fs, path.toUri(), statCache);\n  FsPermission perms = status.getPermission();\n\n  // Encrypted files are always treated as private. This stance has two\n  // important side effects.  The first is that the encrypted files will be\n  // downloaded as the job owner instead of the YARN user, which is required\n  // for the KMS ACLs to work as expected.  Second, it prevent a file with\n  // world readable permissions that is stored in an encryption zone from\n  // being localized as a publicly shared file with world readable\n  // permissions.\n  if (!perms.getEncryptedBit()) {\n    FsAction otherAction = perms.getOtherAction();\n    if (otherAction.implies(action)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"
}