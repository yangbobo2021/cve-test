# Release notes

#set($h2 = '##')
#set($h3 = '###')
#set($h4 = '####')
#set($h5 = '#####')
#set($gborgbug = 'http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?')
#set($pgfbug = 'http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=')
#set($pgffeat = 'http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=')
#set($ghbug = 'https://github.com/tada/pljava/issues/')

$h2 PL/Java 1.5.0

This, the first PL/Java numbered release since 1.4.3 in 2011, combines
compatibility with the latest PostgreSQL and Java versions with modernized
build and installation procedures, automatic generation of SQL deployment
code from Java annotations, and many significant fixes.

$h3 Security

This release brings a policy change to a more secure-by-default posture,
where the ability to create functions in `LANGUAGE java` is no longer
automatically granted to `public`, but can be selectively granted to roles
that will have that responsibility. The change reduces exposure to a known
issue present in 1.5.0 and earlier versions, that will be closed in a future
release ([CVE-2016-0768][], see **large objects, access control** below).

The new policy will be applied in a new installation; permissions will not
be changed in an upgrade, but any site can move to this policy, even before
updating to 1.5.0, with `REVOKE USAGE ON LANGUAGE java FROM public;` followed by
explicit `GRANT` commands for the users/roles expected to create Java
functions.

[CVE-2016-0768]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0768

$h3 Version compatibility

PL/Java 1.5.0 can be built against recent PostgreSQL versions including 9.5,
using Java SE 8, 7, or 6. See [version compatibility][versions] for more
detail. OpenJDK is well supported. Support for GCJ has been dropped.

[versions]: build/versions.html

$h3 Build procedures

Since 2013, PL/Java has been hosted [on GitHub][ghpljava] and built
using [Apache Maven][mvn]. See the new [build instructions][bld] for details.

All reported build issues for MS Windows using Microsoft Visual Studio, and for
Mac OS X, have been resolved, with new platform-specific build documentation
for [Windows MSVC][msvcbld] and [OS X][osxbld].

The build produces a redistributable installation archive usable with
the version of PostgreSQL built against and the same operating system,
architecture, and linker. The type of archive is `jar` on all platforms, as
all PL/Java installations will have Java available.

[ghpljava]: https://github.com/tada/pljava
[mvn]: http://maven.apache.org/
[bld]: build/build.html
[msvcbld]: build/buildmsvc.html
[osxbld]: build/macosx.html

$h3 Installation procedures

The jar produced by the build is executable and will self-extract,
consulting `pg_config` on the destination system to find the correct
default locations for the extracted files. Any location can be overridden.
(Enhancement requests [6][gh6], [9][gh9])

PL/Java now uses a PostgreSQL configuration variable, `pljava.libjvm_location`,
to find the Java runtime to use, eliminating the past need for highly
platform-specific tricks like link-time options or runtime-loader configuration
just so that PL/Java could find Java. PostgreSQL configuration variables are
now the only form of configuration needed for PL/Java, and the `libjvm_location`
should be the only setting needed if file locations have not been overridden.

In PostgreSQL 9.1 and later, PL/Java can be installed with
`CREATE EXTENSION pljava`. Regardless of PostgreSQL version, installation
has been simplified. Former procedures involving `Deployer` or `install.sql`
are no longer required. Details are in the [new installation instructions][ins].

$h4 Schema migration

The tables used internally by PL/Java have changed. If PL/Java 1.5.0 is
loaded in a database with an existing `sqlj` schema populated by an earlier
PL/Java version (1.3.0 or later), the structure will be updated without data
loss (enhancement request [12][gh12]). *Remember that PL/Java runs independently
in each database session where it is in use. Older PL/Java versions active in
other sessions can be disrupted by the schema change.*

A trial installation of PL/Java 1.5.0 can be done in a transaction, and
rolled back if desired, leaving the schema as it was. Any concurrent sessions
with active older PL/Java versions will not be disrupted by the altered schema
as long as the transaction remains open, *but they may block for the duration,
so such a test transaction should be kept short*.

[ins]: install/install.html

$h3 Changes

$h4 `USAGE` to `PUBLIC` no longer default for `java` language

Of the two languages installed by PL/Java, functions that declare
`LANGUAGE javau` can be created only by superusers, while those that
declare `LANGUAGE java` can be created by any user or role granted the
`USAGE` privilege on the language.

In the past, the language `java` has been created with PostgreSQL's
default permission granting `USAGE` to `PUBLIC`, but PL/Java 1.5.0
leaves the permission to be explicitly granted to those users or roles
expected to create Java functions, in keeping with least-privilege
principles. See **large objects, access control** under **known issues**
for background.

$h4 SQL generated by Java annotations

Java code developed for use by PL/Java can carry in-code annotations,
used by the Java compiler to generate the SQL commands to declare the
new functions, types, triggers, etc. in PostgreSQL (enhancement request
[1011112][], though different in implementation). This eliminates the need
to have Java code and the corresponding SQL commands developed in parallel,
and the class of errors possible when both are not updated together. It
also allows compile-time checks that the Java methods or classes being
annotated are suitable (correct access modifiers, signatures, etc.)
for their declared SQL purposes, rather than discovering
such issues only upon loading the code into PostgreSQL and trying to use it.

The Java compiler writes the generated SQL into a "deployment descriptor"
file (`pljava.ddr` by default), as specified by the SQL/JRT standard. The
file can be included in a `jar` archive with the compiled code, and the
commands will be executed by PL/Java when the `install_jar` function is
used to load the jar.

SQL generation is covered in the [updated user documentation][user],
and illustrated in the [Hello, World example][hello] and
[several other supplied examples][exanno]. Reference information
is [in the API documentation][apianno]. It is currently usable to declare
functions, triggers, and user-defined types, both base and composite.

[user]: use/use.html
[hello]: use/hello.html
[exanno]: $project.scm.url/pljava-examples/src/main/java/org/postgresql/pljava/example/annotation
[apianno]: pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/package-summary.html#package_description

The history of this feature in PL/Java is long, with the first related commits
appearing in 2005, six years in advance of an enhancement request for it.
It became generally usable in 2013 when building with
Java SE 6 or later, using the annotation processing framework Java introduced
in that release. 1.5.0 is the first PL/Java numbered release to feature it.

$h5 Annotation keyword changes

If you have been using the SQL generation feature in prerelease `git` builds of
2013 or later, be aware that some annotation keywords have changed in finalizing
the 1.5.0 release. Java code that was compiled using the earlier keywords will
continue to work, but will have to be updated before it can be recompiled.

* For functions: `effects=(VOLATILE,STABLE,IMMUTABLE)` was formerly `type=`
* For functions: `type=` (_an explicit SQL return type for the function_)
    was formerly `complexType=`
* For functions: `trust=(SANDBOXED,UNSANDBOXED)` was formerly
    `(RESTRICTED,UNRESTRICTED)`
* For triggers: `called=(BEFORE,AFTER,INSTEAD_OF)` was formerly `when=`
    and conflicted with the `WHEN` clause introduced for triggers
    in PostgreSQL 9.0.

$h4 A jar may have more than one deployment descriptor

PL/Java formerly allowed only one entry in a jar to be a deployment
descriptor (that is, a file of SQL commands to be executed upon loading
or unloading the jar). The SQL/JRT standard allows multiple entries to
be deployment descriptors, executed in the order they are mentioned
_in the jar manifest_, or the reverse of that order when the jar is
being unloaded. PL/Java now conforms to the standard.

The behavior is useful during transition to annotation-driven deployment
descriptor generation for a project that already has a manually-maintained
deployment descriptor. PL/Java's own `pljava-examples` project is an
illustration, in the midst of such a transition itself.

Note the significance placed by SQL/JRT on the order of entries in a jar
manifest, whose order is normally _not_ significant according to the Jar File
Specification. Care can be needed when manipulating manifests with automated
tools that may not preserve order.

$h4 Conditional execution within deployment descriptors

Deployment descriptors have a primitive conditional-execution provision
defined in the SQL/JRT standard: commands wrapped in a  
`BEGIN IMPLEMENTOR ` _identifier_ construct will only be executed if the
_identifier_ is recognized by the SQL/JRT implementation in use. The design
makes possible jars that can be installed on different database systems that
provide SQL/JRT features, with database-specific commands wrapped in
`BEGIN IMPLEMENTOR` blocks with an _identifier_ specific to the system.
By default, PL/Java recognizes the _identifier_ `postgresql` (matched without
regard to case).

PL/Java extends the standard by allowing the PostgreSQL configuration
variable `pljava.implementors` to contain a list of identifiers that will
be recognized. SQL code in a deployment descriptor can conditionally add
or remove identifiers in this list to influence which subsequent implementor
blocks will be executed, giving a still-primitive but more general control
structure.

In sufficiently recent PostgreSQL versions, the same effect could be
achieved using `DO` statements and PL/pgSQL control structures, but this
facility in PL/Java does not require either to be available.

$h4 Interaction with `SET ROLE` corrected

PL/Java formerly was aware of the user ID associated with the running
session, but not any role ID that user may have acquired with `SET ROLE`.
The result would commonly be failed permission checks made by PL/Java when
the session user did not have the needed permission, but had `SET ROLE` to
a role that did. Likewise, within `install_jar`, PL/Java would execute
deployment descriptor commands as the original session user rather than
as the user's current role, with permission failures a likely result.

Correcting this issue has changed the PL/Java API, but without a bump
of major version because the prior API, while deprecated, is still available.

* [`getOuterUserName`][goun] and [`executeAsOuterUser`][eaou] are new, and
    correctly refer to the session user or current role, when active.
* [`getSessionUserName`][gsun] and [`executeAsSessionUser`][easu] are still
    present but deprecated, and _their semantics are changed_. They are now
    deprecated aliases for the corresponding new methods, which honor the
    set role. Use cases that genuinely need to refer only to the _session_ user
    and ignore the role should be rare, and should be discussed on the mailing
    list or opened as issues.

#set($sessapi = 'pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#')

[goun]: ${sessapi}getOuterUserName()
[eaou]: ${sessapi}executeAsOuterUser(java.sql.Connection,java.lang.String)
[gsun]: ${sessapi}getSessionUserName()
[easu]: ${sessapi}executeAsSessionUser(java.sql.Connection,java.lang.String)

$h4 Unicode transparency

Since the resolution of [bug 21][gh21], PL/Java contains a regression test
to ensure that character strings passed and returned between PostgreSQL and
Java will round-trip without alteration for the full range of Unicode
characters, _when the database encoding is set to `UTF8`_.

More considerations apply when the database encoding is anything other
than `UTF8`, and especially when it is `SQL_ASCII`. Please see
[character encoding support][charsets] for more.

[charsets]: use/charsets.html

$h3 Enhancement requests addressed

* [Use Annotations instead of DDL Manifest][1011112]
* [Installation of pljava on postgresql servers][gh9]
* [Find an alternative way to install the pljava.so in `/usr/lib`][gh6]
* [Provide database migration][gh12]

[1011112]: ${pgffeat}1011112
[gh9]: ${ghbug}9
[gh6]: ${ghbug}6
[gh12]: ${ghbug}12

$h3 Bugs fixed

* [SPIPreparedStatement.setObject() fails with Types.BIT][1011119]
* [SSLSocketFactory throws IOException on Linux][1011095]
* [PL/Java fails to compile with -Werror=format-security][1011181]
* [PL/Java does not build on POWER 7][1011197]
* [The built in functions do not use the correct error codes][1011206]
* [TupleDesc reference leak][1010962]
* [String conversion to enum fails][gh4]
* [segfault if SETOF RECORD-returning function used without AS at callsite][gh7]
* [pl/java PG9.3 Issue][gh17]
* [No-arg functions unusable: "To many parameters - expected 0"][gh8]
* [Exceptions in static initializers are masked][gh54]
* [UDT in varlena form breaks if length > 32767][gh52]
* [PL/Java kills unicode?][gh21]
* [Type.c expects pre-8.3 find_coercion_pathway behavior][gh65]
* [Support PostgreSQL 9.5][gh48]
* [pl/java getting a build on MacOSX - PostgreSQL 9.3.2][gh22]
* [build pljava on windows for PostgreSQL 9.2][gh23]
* [Error while installing PL/Java with Postgresql 9.3.4 64 bit on Windows 7 64 bit System][gh28]
* [pljava does not compile on mac osx ver 10.11.1 and postgres 9.4][gh63]
* [pljava does not compile on centos 6.5 and postgres 9.4][gh64]
* [Error installing pljava with Windows 7 64 Bit and Postgres 9.4][gh71]
## JNI_getIntArrayRegion instead of JNI_getShortArrayRegion
## Eclipse IDE artifacts
## Site
## Warnings
## Javadoc

[1011119]: ${pgfbug}1011119
[1011095]: ${pgfbug}1011095
[1011181]: ${pgfbug}1011181
[1011197]: ${pgfbug}1011197
[1011206]: ${pgfbug}1011206
[1010962]: ${pgfbug}1010962
[gh4]: ${ghbug}4
[gh7]: ${ghbug}7
[gh8]: ${ghbug}8
[gh17]: ${ghbug}17
[gh54]: ${ghbug}54
[gh52]: ${ghbug}52
[gh21]: ${ghbug}21
[gh65]: ${ghbug}65
[gh48]: ${ghbug}48
[gh22]: ${ghbug}22
[gh23]: ${ghbug}23
[gh28]: ${ghbug}28
[gh63]: ${ghbug}63
[gh64]: ${ghbug}64
[gh71]: ${ghbug}71

$h3 Updated PostgreSQL APIs tracked

Several APIs within PostgreSQL itself have been added or changed;
PL/Java now uses the current versions of these where appropriate:

* `find_coercion_pathway`
* `set_stack_base`
* `GetOuterUserId`
* `GetUserNameFromId`
* `GetUserIdAndSecContext`
* `pg_attribute_*`
* Large objects: truncate, and 64-bit offsets

$h3 Known issues and areas for future work

$h4 Developments in PostgreSQL not yet covered

Large objects, access control
: PL/Java does not yet expose PostgreSQL large objects with a documented,
    stable API, and the support it does contain was developed against pre-9.0
    PostgreSQL versions, where no access control applied to large objects and
    any object could be accessed by any database user. PL/Java's behavior is
    proper for PostgreSQL before 9.0, but improper on 9.0+ where it would be
    expected to honor access controls on large objects ([CVE-2016-0768][]).
    This will be corrected in a future release. For this and earlier releases,
    the recommendation is to selectively grant `USAGE` on the `java` language to
    specific users or roles responsible for creating Java functions; see
    "default `USAGE` permssion" under Changes.

`INSTEAD OF` triggers, triggers on `TRUNCATE`
: These are supported by annotations and the SQL generator, and the runtime
    will deliver them to the specified method, but the `TriggerData` interface
    has no new methods to recognize these cases (that is, no added
    methods analogous to `isFiredAfter`, `isFiredByDelete`). For a method
    expressly coded to be a `TRUNCATE` trigger or an `INSTEAD OF` trigger,
    that is not a problem, but care should be taken when coding a trigger
    method to handle more than one type of trigger, or creating triggers of
    these new types that call a method developed pre-PL/Java-1.5.0. Such a
    method could be called with a `TriggerData` argument whose existing
    `isFired...` methods all return `false`, likely to put the method on an
    unexpected code path.

    A later PL/Java version should introduce trigger interfaces that better
    support such evolution of PostgreSQL in a type-safe way.

Constraint triggers
: Constraint trigger syntax is not supported by annotations and the SQL
    generator. If declared (using hand-written SQL), they will be delivered
    by the runtime, but without any constraint-trigger-specific information
    available to the called method.

Event triggers
: Event triggers are not yet supported by annotations or the SQL generator,
    and will not be delivered by the PL/Java runtime.

Range types
: No predefined mappings for range types are provided.

`PRE_PREPARE`, `PRE_COMMIT`, `PARALLEL_ABORT`, `PARALLEL_PRE_COMMIT`, and `PARALLEL_COMMIT` transaction callbacks, `PRE_COMMIT` subtransaction callbacks
: Listeners for these events cannot be registered and the events will not
    be delivered.

$h4 Imperfect integration with PostgreSQL dependency tracking

In a dump/restore, manual intervention can be needed if the users/roles
recorded as owners of jars are missing or have been renamed. A current
[thread on `pgsql-hackers`][ownhack] should yield a better solution for
a future release.

[ownhack]: http://www.postgresql.org/message-id/56783412.6090005@anastigmatix.net

$h4 Quirk if deployment descriptor loads classes from same jar

The `install_jar` function installs a jar, optionally reading deployment
descriptors from the jar and executing the install actions they contain.
It is possible for those actions to load classes from the jar just installed.
(This would be unlikely if the install actions are limited to typical setup,
function/operator/datatype creation, but likely, if the install actions also
include basic function tests, or if the setup requirements are more
interesting.)

If, for any class in the jar, the first attempt to load that class is made
while resolving a function declared `STABLE` or `IMMUTABLE`, a
`ClassNotFoundException` results. The cause is PostgreSQL's normal treatment of
a `STABLE` or `IMMUTABLE` function, which relies on a snapshot from the start of
the `install_jar` query, when the jar was not yet installed. A workaround is to
ensure that the install actions cause each needed class to be loaded, such as
by calling a `VOLATILE` function it supplies, before calling one that is
`STABLE` or `IMMUTABLE`. (One could even write install actions to declare a
needed function `VOLATILE` before the first call and then redeclare it.)

This issue should be resolved as part of a broader rework of class loading
in a future PL/Java release.

$h4 Partial implementation of JDBC 4 and later

The changes to make PL/Java build under Java SE 6 and later, with version 4.0
and later of JDBC, involved providing the specified methods so
compilation would succeed, with real implementations for some, but for others
only stub versions that throw `SQLFeatureNotSupportedException` if used.
Regrettably, there is nothing in the documentation indicating which methods
have real implementations and which do not; to create such a list would require
an audit of that code. If a method throws the exception when you call it, it's
one of the unimplemented ones.

Individual methods may be fleshed out with implementations as use cases arise
that demand them, but for a long-term roadmap, it seems more promising to
reduce the overhead of maintaining another JDBC implementation by sharing
code with `pgjdbc`, as has been [discussed on pljava-dev][jdbcinherit].

[jdbcinherit]: http://lists.pgfoundry.org/pipermail/pljava-dev/2015/002370.html

$h4 Exception handling and logging

PL/Java does interconvert between PostgreSQL and Java exceptions, but with
some loss of fidelity in the two directions. PL/Java code has some access
to most fields of a PostgreSQL error data structure, but only through
internal PL/Java API that is not expected to remain usable, and code written
for PL/Java has never quite had first-class standing in its ability to
_generate_ exceptions as information-rich as those from PostgreSQL itself.

PL/Java in some cases generates the _categorized `SQLException`s_ introduced
with JDBC 4.0, and in other cases does not.

This area may see considerable change in a future release.
[Thoughts on logging][tol] is a preview of some of the considerations.

[tol]: https://github.com/tada/pljava/wiki/Thoughts-on-logging

$h3 Credits

PL/Java 1.5.0 owes its being to original creator Thomas Hallgren and
many contributors:

Daniel Blanch Bataller,
Frank Broda,
Chapman Flack,
Marty Frasier,
Bear Giles,
Christian Hammers,
Hal Hildebrand,
Robert M. Lefkowitz,
Asif Naeem,
Kenneth Olson,
Johann Oskarsson,
Thomas G. Peters,
Srivatsan Ramanujam,
Jeff Shaw,
Rakesh Vidyadharan,
`grunjol`,
`mc-soi`.

Periods in PL/Java's development have been sponsored by EnterpriseDB.

In the 1.5.0 release cycle, multiple iterations of testing effort
have been generously contributed by Kilobe Systems and by Pegasystems, Inc.

$h2 Earlier releases

$h3 PL/Java 1.4.3 (15 September 2011)

Notable changes in this release:

* Works with PostgreSQL 9.1
* Correctly links against IBM Java.
* Reads microseconds correctly in timestamps.

Bugs fixed:

* [Be clear about not building with JDK 1.6][1010660]
* [Does not link with IBM VM][1010970]
* [SPIConnection.getMetaData() is incorrectly documented][1010971]
* [PL/Java 1.4.2 Does not build with x86_64-w64-mingw32][1011025]
* [PL/Java does not build with PostgreSQL 9.1][1011091]

Feature Requests:

* [Allow pg_config to be set externally to the Makefile][1011092]
* [Add option to have pljava.so built with the runtime path of libjvm.so][1010955]

[1010660]: ${pgfbug}1010660
[1010970]: ${pgfbug}1010970
[1010971]: ${pgfbug}1010971
[1011025]: ${pgfbug}1011025
[1011091]: ${pgfbug}1011091

[1011092]: ${pgffeat}1011092
[1010955]: ${pgffeat}1010955

$h3 PL/Java 1.4.2 (11 December 2010)

Bugfixes:

* [Function returning complex objects with POD arrays cause a segfault][1010956]
* [Segfault when assigning an array to ResultSet column][1010953]
* [Embedded array support in returned complex objects][1010482]

[1010956]: ${pgfbug}1010956
[1010953]: ${pgfbug}1010953
[1010482]: ${pgfbug}1010482

$h3 PL/Java 1.4.1 (9 December 2010)

Note: Does not compile with Java 6.  Use JDK 1.5 or 1.4.

Compiles with PostgreSQL 8.4 and 9.0.

Connection.getCatalog() has been implemented.

Bugfixes:

* [Compiling error with postgresql 8.4.1][1010759]
* [org.postgresql.pljava.internal.Portal leak][1010712]
* [build java code with debugging if server has debugging enabled][1010189]
* [Connection.getCatalog() returns null][1010653]
* [VM crash in TransactionListener][1010462]
* [Link against wrong library when compiling amd64 code on Solaris][1010954]

[1010759]: ${pgfbug}1010759
[1010712]: ${pgfbug}1010712
[1010189]: ${pgfbug}1010189
[1010653]: ${pgfbug}1010653
[1010462]: ${pgfbug}1010462
[1010954]: ${pgfbug}1010954

Other commits:

For a multi-threaded pljava function we need to adjust stack_base_ptr
before calling into the backend to avoid stack depth limit exceeded
errors.  Previously this was done only on query execution, but we need
to do it on iteration of the ResultSet as well.

When creating a variable length data type, the code was directly
assigning the varlena header length rather than going through an
access macro.  The header format changed for the 8.3 release and this
manual coding was not noticed and changed accordingly.  Use
SET_VARSIZE to do this correctly.

Handle passed by value data types by reading and writing directly to
the Datum rather than dereferencing it.

If the call to a type output function is the first pljava call in a
session, we get a crash.  The first pljava call results in a SPI
connection being established and torn down.  The type output function
was allocating the result in the SPI memory context which gets
destroyed prior to returning the data to the caller.  Allocate the
result in the correct context to survive function exit.

Clean up a warning about byteasend and bytearecv not having a
prototype when building against 9.0 as those declarations are now in a
new header file.


$h3 PL/Java 1.4.0 (1 February 2008)

Warning! The recent postgresql security releases changed the API of a function
that PL/Java uses. The source can be built against either version, but the
binaries will only run against the version they were built against. The PL/Java
binaries for 1.4.0 have all been built against the latest server releases (which
you should be using anyway). If you are using an older you will have to build
from source. The binary releases support: 8.3 - All versions. 8.2 - 8.2.6 and
up. 8.1 - 8.1.11 and up. 8.0 - 8.0.15 and up.

$h3 PL/Java 1.3.0 (18 June 2006)

This release is about type mapping and the creation of new types in PL/Java. An
extensive effort has gone into making the PL/Java type system extremely
flexible. Not only can you map arbitrary SQL data types to java classes. You can
also create new scalar types completely in Java. Read about the Changes in
version 1.3.

$h4 Changes

* A much improved type mapping system that will allow you to:

    * [Map any SQL type to a Java class][maptype]
    * [Create a Scalar UDT in Java][scalarudt]
    * [Map array and pseudo types][deftypemap]

[maptype]: https://github.com/tada/pljava/wiki/Mapping-an-sql-type-to-a-java-class
[scalarudt]: https://github.com/tada/pljava/wiki/Creating-a-scalar-udt-in-java
[deftypemap]: https://github.com/tada/pljava/wiki/Default-type-mapping

* Get the OID for a given relation ([feature request 1319][1319])
* Jar manifest included in the SQLJ Jar repository
    ([feature request 1525][1525])

$h4 Fixed bugs

* [Reconnect needed for jar manipulation to take effect][1531]
* [Backends hang with test suite][1504]
* [Keeps crashing while making a call to a function][1560]
* [Memory Leak in Statement.executeUpdate][1556]
* [jarowner incorrect after dump and reload][1506]
* [Missing JAR manifest][1525]
* [TZ adjustments for Date are incorrect][1547]
* [Functions returning sets leaks memory][1542]
* [drop lib prefix][1423]
* ["oid" column is not available in trigger's NEW/OLD ResultSet][1317]
* [fails to run with GCJ, too][1480]
* [Compile failure with 8.1.4][1558]
* [fails to build with GCJ][1479]
* [Record returning function cannot be called with different structures within one session][1440]
* [Cannot map function with complex return type to method that uses non primitive arguments][1551]
* [Get OID for given relation][1319]

[1531]: ${gborgbug}1531
[1504]: ${gborgbug}1504
[1560]: ${gborgbug}1560
[1556]: ${gborgbug}1556
[1506]: ${gborgbug}1506
[1525]: ${gborgbug}1525
[1547]: ${gborgbug}1547
[1542]: ${gborgbug}1542
[1423]: ${gborgbug}1423
[1317]: ${gborgbug}1317
[1480]: ${gborgbug}1480
[1558]: ${gborgbug}1558
[1479]: ${gborgbug}1479
[1440]: ${gborgbug}1440
[1551]: ${gborgbug}1551
[1319]: ${gborgbug}1319

$h3 PL/Java 1.2.0 (20 Nov 2005)

The PL/Java 1.2.0 release is primarily targeted at the new PostgreSQL 8.1 but
full support for 8.0.x is maintained. New features include support IN/OUT
parameters, improved meta-data handling, and better memory management.

$h3 PL/Java 1.1.0 (14 Apr 2005)

PL/Java 1.1.0 includes a lot of new features such as `DatabaseMetaData`,
`ResultSetMetaData`, language handlers for both trusted and untrusted language,
additional semantics for functions returning `SETOF`, and simple ObjectPooling.

$h3 PL/Java 1.0.1 (07 Feb 2005)

This release resolves a couple of important security issues. The most important
one is perhaps that PL/Java now is a trusted language. See [Security][] for more
info. Filip Hrbek, now member of the PL/Java project, contributed what was
needed to make this happen.

[Security]: https://github.com/tada/pljava/wiki/Security

$h3 PL/Java 1.0.0 (23 Jan 2005)

Today, after a long period of fine tuning, PL/Java 1.0.0 was finally released.
