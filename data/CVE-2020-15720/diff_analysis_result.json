{
    "before_functions": "class SSLContextAdapter(adapters.HTTPAdapter):\n    \"\"\"Custom SSLContext Adapter for requests\n    \"\"\"\n    def init_poolmanager(self, connections, maxsize,\n                         block=adapters.DEFAULT_POOLBLOCK, **pool_kwargs):\n        context = ssl.SSLContext(\n            ssl.PROTOCOL_TLS  # pylint: disable=no-member\n        )\n\n        # Enable post handshake authentication for TLS 1.3\n        if getattr(context, \"post_handshake_auth\", None) is not None:\n            context.post_handshake_auth = True\n\n        pool_kwargs['ssl_context'] = context\n        return super().init_poolmanager(\n            connections, maxsize, block, **pool_kwargs\n        )\n\nclass PKIConnection:\n    \"\"\"\n    Class to encapsulate the connection between the client and a Dogtag\n    subsystem.\n    \"\"\"\n\n    def __init__(self, protocol='http', hostname='localhost', port='8080',\n                 subsystem=None, accept='application/json',\n                 trust_env=None, verify=False):\n        \"\"\"\n        Set the parameters for a python-requests based connection to a\n        Dogtag subsystem.\n        :param protocol: http or https\n        :type protocol: str\n        :param hostname: hostname of server\n        :type hostname: str\n        :param port: port of server\n        :type port: str\n        :param subsystem: Subsystem name: ca, kra, ocsp, tks, tps.\n           DEPRECATED: https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes\n        :type subsystem: str\n        :param accept: value of accept header.  Supported values are usually\n           'application/json' or 'application/xml'\n        :type accept: str\n        :param trust_env: use environment variables for http proxy and other\n           requests settings (default: yes)\n        :type trust_env: bool, None\n        :param verify: verify TLS/SSL connections and configure CA certs\n           (default: no)\n        :type verify: None, bool, str\n        :return: PKIConnection object.\n        \"\"\"\n\n        self.protocol = protocol\n        self.hostname = hostname\n        self.port = port\n        self.subsystem = subsystem\n\n        self.rootURI = self.protocol + '://' + self.hostname + ':' + self.port\n\n        if subsystem is not None:\n            logger.warning(\n                '%s:%s: The subsystem in PKIConnection.__init__() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            self.serverURI = self.rootURI + '/' + subsystem\n        else:\n            self.serverURI = self.rootURI\n\n        self.session = requests.Session()\n        self.session.mount(\"https://\", SSLContextAdapter())\n        self.session.trust_env = trust_env\n        self.session.verify = verify\n\n        if accept:\n            self.session.headers.update({'Accept': accept})\n",
    "after_functions": "class SSLContextAdapter(adapters.HTTPAdapter):\n    \"\"\"\n    Custom SSLContext Adapter for requests\n    \"\"\"\n\n    def __init__(self, pool_connections=DEFAULT_POOLSIZE,\n                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,\n                 pool_block=DEFAULT_POOLBLOCK, verify=True,\n                 cert_paths=None):\n        self.verify = verify\n        self.cafiles = []\n        self.capaths = []\n\n        cert_paths = cert_paths or []\n\n        if isinstance(cert_paths, str):\n            cert_paths = [cert_paths]\n\n        for path in cert_paths:\n            path = path and os.path.expanduser(path)\n\n            if os.path.isdir(path):\n                self.capaths.append(path)\n            elif os.path.exists(path):\n                self.cafiles.append(path)\n            else:\n                logger.warning(\"cert_path missing; not used for validation: %s\",\n                               path)\n\n        # adapters.HTTPAdapter.__init__ calls our init_poolmanager, which needs\n        # our cafiles/capaths variables we set up above.\n        super(SSLContextAdapter, self).__init__(pool_connections=pool_connections,\n                                                pool_maxsize=pool_maxsize,\n                                                max_retries=max_retries,\n                                                pool_block=pool_block)\n\n    def init_poolmanager(self, connections, maxsize,\n                         block=adapters.DEFAULT_POOLBLOCK, **pool_kwargs):\n        context = ssl.SSLContext(\n            ssl.PROTOCOL_TLS  # pylint: disable=no-member\n        )\n\n        # Enable post handshake authentication for TLS 1.3\n        if getattr(context, \"post_handshake_auth\", None) is not None:\n            context.post_handshake_auth = True\n\n        # Load from the system trust store when possible; per documentation\n        # this call could silently fail and refuse to configure any\n        # certificates. In this instance, the user should provide a\n        # certificate manually.\n        context.set_default_verify_paths()\n\n        # Load any specific certificate paths that have been specified during\n        # adapter initialization.\n        for cafile in self.cafiles:\n            context.load_verify_locations(cafile=cafile)\n        for capath in self.capaths:\n            context.load_verify_locations(capath=capath)\n\n        if self.verify:\n            # Enable certificate verification\n            context.verify_mode = ssl.VerifyMode.CERT_REQUIRED  # pylint: disable=no-member\n\n        pool_kwargs['ssl_context'] = context\n        return super().init_poolmanager(\n            connections, maxsize, block, **pool_kwargs\n        )\n\nclass PKIConnection:\n    \"\"\"\n    Class to encapsulate the connection between the client and a Dogtag\n    subsystem.\n    \"\"\"\n\n    def __init__(self, protocol='http', hostname='localhost', port='8080',\n                 subsystem=None, accept='application/json',\n                 trust_env=None, verify=True, cert_paths=None):\n        \"\"\"\n        Set the parameters for a python-requests based connection to a\n        Dogtag subsystem.\n        :param protocol: http or https\n        :type protocol: str\n        :param hostname: hostname of server\n        :type hostname: str\n        :param port: port of server\n        :type port: str\n        :param subsystem: Subsystem name: ca, kra, ocsp, tks, tps.\n           DEPRECATED: https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes\n        :type subsystem: str\n        :param accept: value of accept header.  Supported values are usually\n           'application/json' or 'application/xml'\n        :type accept: str\n        :param trust_env: use environment variables for http proxy and other\n           requests settings (default: yes)\n        :type trust_env: bool, None\n        :param verify: verify TLS/SSL connections and configure CA certs\n           (default: no)\n        :type verify: None, bool, str\n        :param cert_paths: paths to CA certificates / directories in OpenSSL\n          format. (default: None)\n        :type cert_paths: None, str, list\n        :return: PKIConnection object.\n        \"\"\"\n\n        self.protocol = protocol\n        self.hostname = hostname\n        self.port = port\n        self.subsystem = subsystem\n\n        self.rootURI = self.protocol + '://' + self.hostname + ':' + self.port\n\n        if subsystem is not None:\n            logger.warning(\n                '%s:%s: The subsystem in PKIConnection.__init__() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            self.serverURI = self.rootURI + '/' + subsystem\n        else:\n            self.serverURI = self.rootURI\n\n        self.session = requests.Session()\n        self.session.mount(\"https://\", SSLContextAdapter(verify=verify, cert_paths=cert_paths))\n        self.session.trust_env = trust_env\n        self.session.verify = verify\n\n        if accept:\n            self.session.headers.update({'Accept': accept})\n"
}