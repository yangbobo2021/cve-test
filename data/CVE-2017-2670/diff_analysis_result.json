{
    "before_functions": "void resumeReadsInternal(boolean wakeup) {\n    synchronized (lock) {\n        boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n        state |= STATE_READS_RESUMED;\n        if (!alreadyResumed || wakeup) {\n            if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                state |= STATE_IN_LISTENER_LOOP;\n                getFramedChannel().runInIoThread(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        try {\n                            boolean moreData;\n                            do {\n                                ChannelListener<? super R> listener = getReadListener();\n                                if (listener == null || !isReadResumed()) {\n                                    return;\n                                }\n                                ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                //if writes are shutdown or we become active then we stop looping\n                                //we stop when writes are shutdown because we can't flush until we are active\n                                //although we may be flushed as part of a batch\n                                moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                            }\n                            while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);\n                        } finally {\n                            state &= ~STATE_IN_LISTENER_LOOP;\n                        }\n                    }\n                });\n            }\n        }\n    }\n}\n",
    "after_functions": "void resumeReadsInternal(boolean wakeup) {\n    synchronized (lock) {\n        boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n        state |= STATE_READS_RESUMED;\n        if (!alreadyResumed || wakeup) {\n            if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                state |= STATE_IN_LISTENER_LOOP;\n                getFramedChannel().runInIoThread(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        try {\n                            boolean moreData;\n                            do {\n                                ChannelListener<? super R> listener = getReadListener();\n                                if (listener == null || !isReadResumed()) {\n                                    return;\n                                }\n                                ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                //if writes are shutdown or we become active then we stop looping\n                                //we stop when writes are shutdown because we can't flush until we are active\n                                //although we may be flushed as part of a batch\n                                moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                            }\n                            while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);\n                        } finally {\n                            state &= ~STATE_IN_LISTENER_LOOP;\n                        }\n                    }\n                });\n            }\n        }\n    }\n}\n"
}