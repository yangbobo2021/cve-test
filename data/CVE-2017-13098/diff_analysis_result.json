{
    "before_functions": "protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                               byte[] encryptedPreMasterSecret)\n{\n    SecureRandom secureRandom = crypto.getSecureRandom();\n\n    /*\n     * RFC 5246 7.4.7.1.\n     */\n    ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n    // TODO Provide as configuration option?\n    boolean versionNumberCheckDisabled = false;\n\n    /*\n     * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n     * PKCS1 padding check should fail.\n     */\n    byte[] fallback = new byte[48];\n    secureRandom.nextBytes(fallback);\n\n    byte[] M = Arrays.clone(fallback);\n    try\n    {\n        Cipher c = crypto.createRSAEncryptionCipher();\n        c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n        M = c.doFinal(encryptedPreMasterSecret);\n    }\n    catch (Exception e)\n    {\n        /*\n         * A TLS server MUST NOT generate an alert if processing an\n         * RSA-encrypted premaster secret message fails, or the version number is not as\n         * expected. Instead, it MUST continue the handshake with a randomly generated\n         * premaster secret.\n         */\n    }\n\n    /*\n     * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n     * check the version number [..].\n     */\n    if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n    {\n        /*\n         * If the version number is TLS 1.0 or earlier, server\n         * implementations SHOULD check the version number, but MAY have a\n         * configuration option to disable the check.\n         *\n         * So there is nothing to do here.\n         */\n    }\n    else\n    {\n        /*\n         * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n         * clientVersion received during the handshake. If they don't match, we replace the\n         * decrypted Pre-Master-Secret with a random one.\n         */\n        int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n            | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n        correct |= correct >> 1;\n        correct |= correct >> 2;\n        correct |= correct >> 4;\n        int mask = ~((correct & 1) - 1);\n\n        /*\n         * mask will be all bits set to 0xff if the version number differed.\n         */\n        for (int i = 0; i < 48; i++)\n        {\n            M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n        }\n    }\n    return crypto.createSecret(M);\n}\n",
    "after_functions": "protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                               byte[] encryptedPreMasterSecret)\n{\n    SecureRandom secureRandom = crypto.getSecureRandom();\n\n    /*\n     * RFC 5246 7.4.7.1.\n     */\n    ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n    // TODO Provide as configuration option?\n    boolean versionNumberCheckDisabled = false;\n\n    /*\n     * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n     * PKCS1 padding check should fail.\n     */\n    byte[] fallback = new byte[48];\n    secureRandom.nextBytes(fallback);\n\n    byte[] M = Arrays.clone(fallback);\n    try\n    {\n        Cipher c = crypto.createRSAEncryptionCipher();\n        c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n        byte[] m = c.doFinal(encryptedPreMasterSecret);\n        if (m != null && m.length == 48)\n        {\n            M = m;\n        }\n    }\n    catch (Exception e)\n    {\n        /*\n         * A TLS server MUST NOT generate an alert if processing an\n         * RSA-encrypted premaster secret message fails, or the version number is not as\n         * expected. Instead, it MUST continue the handshake with a randomly generated\n         * premaster secret.\n         */\n    }\n\n    /*\n     * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n     * check the version number [..].\n     */\n    if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n    {\n        /*\n         * If the version number is TLS 1.0 or earlier, server\n         * implementations SHOULD check the version number, but MAY have a\n         * configuration option to disable the check.\n         *\n         * So there is nothing to do here.\n         */\n    }\n    else\n    {\n        /*\n         * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n         * clientVersion received during the handshake. If they don't match, we replace the\n         * decrypted Pre-Master-Secret with a random one.\n         */\n        int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n            | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n        correct |= correct >> 1;\n        correct |= correct >> 2;\n        correct |= correct >> 4;\n        int mask = ~((correct & 1) - 1);\n\n        /*\n         * mask will be all bits set to 0xff if the version number differed.\n         */\n        for (int i = 0; i < 48; i++)\n        {\n            M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n        }\n    }\n    return crypto.createSecret(M);\n}\n"
}