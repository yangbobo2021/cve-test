{
    "before_functions": "def generate(bits, randfunc, progress_func=None):\n    \"\"\"Randomly generate a fresh, new ElGamal key.\n\n    :Parameters:\n        bits : int\n            Key length, or size (in bits) of the modulus *p*.\n            Recommended value is 2048.\n        randfunc : callable\n            Random number generation function; it should accept\n            a single integer N and return a string of random data\n            N bytes long.\n        progress_func : callable\n            Optional function that will be called with a short string\n            containing the key parameter currently being generated;\n            it's useful for interactive applications where a user is\n            waiting for a key to be generated.\n\n    :attention: You should always use a cryptographically secure random number generator,\n        such as the one defined in the ``Crypto.Random`` module; **don't** just use the\n        current time and the ``random`` module.\n\n    :Return: An ElGamal key object (`ElGamalobj`).\n    \"\"\"\n    obj=ElGamalobj()\n    # Generate prime p\n    if progress_func:\n        progress_func('p\\n')\n    obj.p=bignum(getPrime(bits, randfunc))\n    # Generate random number g\n    if progress_func:\n        progress_func('g\\n')\n    size=bits-1-(ord(randfunc(1)) & 63) # g will be from 1--64 bits smaller than p\n    if size<1:\n        size=bits-1\n    while (1):\n        obj.g=bignum(getPrime(size, randfunc))\n        if obj.g < obj.p:\n            break\n        size=(size+1) % bits\n        if size==0:\n            size=4\n    # Generate random number x\n    if progress_func:\n        progress_func('x\\n')\n    while (1):\n        size=bits-1-ord(randfunc(1)) # x will be from 1 to 256 bits smaller than p\n        if size>2:\n            break\n    while (1):\n        obj.x=bignum(getPrime(size, randfunc))\n        if obj.x < obj.p:\n            break\n        size = (size+1) % bits\n        if size==0:\n            size=4\n    if progress_func:\n        progress_func('y\\n')\n    obj.y = pow(obj.g, obj.x, obj.p)\n    return obj\n\ndef _verify(self, M, sig):\n    v1=pow(self.y, sig[0], self.p)\n    v1=(v1*pow(sig[0], sig[1], self.p)) % self.p\n    v2=pow(self.g, M, self.p)\n    if v1==v2:\n        return 1\n    return 0\n",
    "after_functions": "def generate(bits, randfunc, progress_func=None):\n    \"\"\"Randomly generate a fresh, new ElGamal key.\n\n    The key will be safe for use for both encryption and signature\n    (although it should be used for **only one** purpose).\n\n    :Parameters:\n        bits : int\n            Key length, or size (in bits) of the modulus *p*.\n            Recommended value is 2048.\n        randfunc : callable\n            Random number generation function; it should accept\n            a single integer N and return a string of random data\n            N bytes long.\n        progress_func : callable\n            Optional function that will be called with a short string\n            containing the key parameter currently being generated;\n            it's useful for interactive applications where a user is\n            waiting for a key to be generated.\n\n    :attention: You should always use a cryptographically secure random number generator,\n        such as the one defined in the ``Crypto.Random`` module; **don't** just use the\n        current time and the ``random`` module.\n\n    :Return: An ElGamal key object (`ElGamalobj`).\n    \"\"\"\n    obj=ElGamalobj()\n    # Generate a safe prime p\n    # See Algorithm 4.86 in Handbook of Applied Cryptography\n    if progress_func:\n        progress_func('p\\n')\n    while 1:\n        q = bignum(getPrime(bits-1, randfunc))\n        obj.p = 2*q+1\n        if number.isPrime(obj.p, randfunc=randfunc):\n            break\n    # Generate generator g\n    # See Algorithm 4.80 in Handbook of Applied Cryptography\n    # Note that the order of the group is n=p-1=2q, where q is prime\n    if progress_func:\n        progress_func('g\\n')\n    while 1:\n        # We must avoid g=2 because of Bleichenbacher's attack described\n        # in \"Generating ElGamal signatures without knowning the secret key\",\n        # 1996\n        #\n        obj.g = number.getRandomRange(3, obj.p, randfunc)\n        safe = 1\n        if pow(obj.g, 2, obj.p)==1:\n            safe=0\n        if safe and pow(obj.g, q, obj.p)==1:\n            safe=0\n        # Discard g if it divides p-1 because of the attack described\n        # in Note 11.67 (iii) in HAC\n        if safe and divmod(obj.p-1, obj.g)[1]==0:\n            safe=0\n        # g^{-1} must not divide p-1 because of Khadir's attack\n        # described in \"Conditions of the generator for forging ElGamal\n        # signature\", 2011\n        ginv = number.inverse(obj.g, obj.p)\n        if safe and divmod(obj.p-1, ginv)[1]==0:\n            safe=0\n        if safe:\n            break\n    # Generate private key x\n    if progress_func:\n        progress_func('x\\n')\n    obj.x=number.getRandomRange(2, obj.p-1, randfunc)\n    # Generate public key y\n    if progress_func:\n        progress_func('y\\n')\n    obj.y = pow(obj.g, obj.x, obj.p)\n    return obj\n\ndef _verify(self, M, sig):\n    if sig[0]<1 or sig[0]>p-1:\n        return 0\n    v1=pow(self.y, sig[0], self.p)\n    v1=(v1*pow(sig[0], sig[1], self.p)) % self.p\n    v2=pow(self.g, M, self.p)\n    if v1==v2:\n        return 1\n    return 0\n"
}