{
    "before_functions": "@Override\npublic void open() throws TTransportException {\n  /*\n   * readSaslHeader is used to tag whether the SASL header has been read properly.\n   * If there is a problem in reading the header, there might not be any\n   * data in the stream, possibly a TCP health check from load balancer.\n   */\n  boolean readSaslHeader = false;\n\n  LOGGER.debug(\"opening transport {}\", this);\n  if (sasl != null && sasl.isComplete())\n    throw new TTransportException(\"SASL transport already open\");\n\n  if (!underlyingTransport.isOpen())\n    underlyingTransport.open();\n\n  try {\n    // Negotiate a SASL mechanism. The client also sends its\n    // initial response, or an empty one.\n    handleSaslStartMessage();\n    readSaslHeader = true;\n    LOGGER.debug(\"{}: Start message handled\", getRole());\n\n    SaslResponse message = null;\n    while (!sasl.isComplete()) {\n      message = receiveSaslMessage();\n      if (message.status != NegotiationStatus.COMPLETE &&\n          message.status != NegotiationStatus.OK) {\n        throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n      }\n\n      byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n      // If we are the client, and the server indicates COMPLETE, we don't need to\n      // send back any further response.\n      if (message.status == NegotiationStatus.COMPLETE &&\n          getRole() == SaslRole.CLIENT) {\n        LOGGER.debug(\"{}: All done!\", getRole());\n        break;\n      }\n\n      sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                      challenge);\n    }\n    LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n    assert sasl.isComplete();\n\n    // If we're the client, and we're complete, but the server isn't\n    // complete yet, we need to wait for its response. This will occur\n    // with ANONYMOUS auth, for example, where we send an initial response\n    // and are immediately complete.\n    if (getRole() == SaslRole.CLIENT &&\n        (message == null || message.status == NegotiationStatus.OK)) {\n      LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n      message = receiveSaslMessage();\n      if (message.status != NegotiationStatus.COMPLETE) {\n        throw new TTransportException(\n          \"Expected SASL COMPLETE, but got \" + message.status);\n      }\n    }\n  } catch (SaslException e) {\n    try {\n      LOGGER.error(\"SASL negotiation failure\", e);\n      throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n    } finally {\n      underlyingTransport.close();\n    }\n  } catch (TTransportException e) {\n    /*\n     * If there is no-data or no-sasl header in the stream, throw a different\n     * type of exception so we can handle this scenario differently.\n     */\n    if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n      underlyingTransport.close();\n      LOGGER.debug(\"No data or no sasl data in the stream\");\n      throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n    }\n    throw e;\n  }\n\n  String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n  if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n    shouldWrap = true;\n}\n",
    "after_functions": "@Override\npublic void open() throws TTransportException {\n  /*\n   * readSaslHeader is used to tag whether the SASL header has been read properly.\n   * If there is a problem in reading the header, there might not be any\n   * data in the stream, possibly a TCP health check from load balancer.\n   */\n  boolean readSaslHeader = false;\n\n  LOGGER.debug(\"opening transport {}\", this);\n  if (sasl != null && sasl.isComplete())\n    throw new TTransportException(\"SASL transport already open\");\n\n  if (!underlyingTransport.isOpen())\n    underlyingTransport.open();\n\n  try {\n    // Negotiate a SASL mechanism. The client also sends its\n    // initial response, or an empty one.\n    handleSaslStartMessage();\n    readSaslHeader = true;\n    LOGGER.debug(\"{}: Start message handled\", getRole());\n\n    SaslResponse message = null;\n    while (!sasl.isComplete()) {\n      message = receiveSaslMessage();\n      if (message.status != NegotiationStatus.COMPLETE &&\n          message.status != NegotiationStatus.OK) {\n        throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n      }\n\n      byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n      // If we are the client, and the server indicates COMPLETE, we don't need to\n      // send back any further response.\n      if (message.status == NegotiationStatus.COMPLETE &&\n          getRole() == SaslRole.CLIENT) {\n        LOGGER.debug(\"{}: All done!\", getRole());\n        continue;\n      }\n\n      sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                      challenge);\n    }\n    LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n    // If we're the client, and we're complete, but the server isn't\n    // complete yet, we need to wait for its response. This will occur\n    // with ANONYMOUS auth, for example, where we send an initial response\n    // and are immediately complete.\n    if (getRole() == SaslRole.CLIENT &&\n        (message == null || message.status == NegotiationStatus.OK)) {\n      LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n      message = receiveSaslMessage();\n      if (message.status != NegotiationStatus.COMPLETE) {\n        throw new TTransportException(\n          \"Expected SASL COMPLETE, but got \" + message.status);\n      }\n    }\n  } catch (SaslException e) {\n    try {\n      LOGGER.error(\"SASL negotiation failure\", e);\n      throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n    } finally {\n      underlyingTransport.close();\n    }\n  } catch (TTransportException e) {\n    /*\n     * If there is no-data or no-sasl header in the stream, throw a different\n     * type of exception so we can handle this scenario differently.\n     */\n    if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n      underlyingTransport.close();\n      LOGGER.debug(\"No data or no sasl data in the stream\");\n      throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n    }\n    throw e;\n  }\n\n  String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n  if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n    shouldWrap = true;\n}\n"
}