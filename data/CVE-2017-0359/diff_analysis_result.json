{
    "before_functions": "class LibarchiveContainer(Archive):\n    def open_archive(self):\n        # libarchive is very very stream oriented an not for random access\n        # so we are going to reopen the archive everytime\n        # not nice, but it'll work\n        return True\n\n    def close_archive(self):\n        pass\n\n    def get_member_names(self):\n        self.ensure_unpacked()\n        return self._member_names\n\n    def extract(self, member_name, dest_dir):\n        self.ensure_unpacked()\n        return os.path.join(self._unpacked, member_name)\n\n    def get_member(self, member_name):\n        with libarchive.file_reader(self.source.path) as archive:\n            for entry in archive:\n                if entry.pathname == member_name:\n                    return self.get_subclass(entry)\n        raise KeyError('%s not found in archive', member_name)\n\n    def get_all_members(self):\n        with libarchive.file_reader(self.source.path) as archive:\n            for entry in archive:\n                yield entry.pathname, self.get_subclass(entry)\n\n    def get_subclass(self, entry):\n        if entry.isdir:\n            return LibarchiveDirectory(self, entry)\n        elif entry.issym:\n            return LibarchiveSymlink(self, entry)\n        elif entry.isblk or entry.ischr:\n            return LibarchiveDevice(self, entry)\n\n        return LibarchiveMember(self, entry)\n\n    def ensure_unpacked(self):\n        if hasattr(self, '_unpacked'):\n            return\n\n        self._unpacked = get_temporary_directory().name\n        self._member_names = []\n\n        logger.debug(\"Extracting %s to %s\", self.source.path, self._unpacked)\n\n        with libarchive.file_reader(self.source.path) as archive:\n            for entry in archive:\n                self._member_names.append(entry.pathname)\n\n                if entry.isdir:\n                    continue\n\n                # All extracted locations must be underneath self._unpacked\n                force_prefix = os.path.join(self._unpacked, \"\")\n\n                # Try to pick a safe and reasonable candidate name\n                candidate_name = os.path.normpath(entry.pathname.rstrip('/' + os.sep))\n                if os.path.isabs(candidate_name):\n                    candidate_name = os.path.relpath(candidate_name, os.path.join(os.path.sep))\n\n                dst = os.path.normpath(os.path.join(self._unpacked, candidate_name))\n                if not dst.startswith(force_prefix):\n                    logger.warn(\"Skipping member because we could not make a safe name to extract it to: '%s'\",\n                                entry.pathname)\n                    continue\n\n                # TODO: need to fix reading these cleaned members. currently\n                # reading will still try to use the uncleaned name.\n                #logging.debug(\"Extracting %s to %s\", entry.pathname, dst)\n                os.makedirs(os.path.dirname(dst), exist_ok=True)\n\n                with open(dst, 'wb') as f:\n                    for block in entry.get_blocks():\n                        f.write(block)\n\n        logger.debug(\n            \"Extracted %d entries from %s to %s\",\n            len(self._member_names), self.source.path, self._unpacked,\n        )\n",
    "after_functions": "class LibarchiveContainer(Archive):\n    def open_archive(self):\n        # libarchive is very very stream oriented an not for random access\n        # so we are going to reopen the archive everytime\n        # not nice, but it'll work\n        return True\n\n    def close_archive(self):\n        pass\n\n    def get_member_names(self):\n        self.ensure_unpacked()\n        return self._members.keys()\n\n    def extract(self, member_name, dest_dir):\n        self.ensure_unpacked()\n        return self._members[member_name]\n\n    def get_member(self, member_name):\n        with libarchive.file_reader(self.source.path) as archive:\n            for entry in archive:\n                if entry.pathname == member_name:\n                    return self.get_subclass(entry)\n        raise KeyError('%s not found in archive', member_name)\n\n    def get_all_members(self):\n        with libarchive.file_reader(self.source.path) as archive:\n            for entry in archive:\n                yield entry.pathname, self.get_subclass(entry)\n\n    def get_subclass(self, entry):\n        if entry.isdir:\n            return LibarchiveDirectory(self, entry)\n        elif entry.issym:\n            return LibarchiveSymlink(self, entry)\n        elif entry.isblk or entry.ischr:\n            return LibarchiveDevice(self, entry)\n\n        return LibarchiveMember(self, entry)\n\n    def ensure_unpacked(self):\n        if hasattr(self, '_members'):\n            return\n\n        tmpdir = get_temporary_directory().name\n        self._members = collections.OrderedDict()\n\n        logger.debug(\"Extracting %s to %s\", self.source.path, tmpdir)\n\n        with libarchive.file_reader(self.source.path) as archive:\n            for idx, entry in enumerate(archive):\n                # Maintain a mapping of archive path to the extracted path,\n                # avoiding the need to sanitise filenames.\n                dst = os.path.join(tmpdir, '{}'.format(idx))\n                self._members[entry.pathname] = dst\n\n                if entry.isdir:\n                    continue\n\n                logger.debug(\"Extracting %s to %s\", entry.pathname, dst)\n\n                with open(dst, 'wb') as f:\n                    for block in entry.get_blocks():\n                        f.write(block)\n\n        logger.debug(\n            \"Extracted %d entries from %s to %s\",\n            len(self._members), self.source.path, tmpdir,\n        )\n"
}