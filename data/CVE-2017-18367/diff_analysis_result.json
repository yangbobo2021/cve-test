{
    "before_functions": "// Wrapper to create an scmp_arg_cmp struct\nvoid*\nmake_struct_arg_cmp(\n                    unsigned int arg,\n                    int compare,\n                    uint64_t a,\n                    uint64_t b\n                   )\n{\n\tstruct scmp_arg_cmp *s = malloc(sizeof(struct scmp_arg_cmp));\n\n\ts->arg = arg;\n\ts->op = compare;\n\ts->datum_a = a;\n\ts->datum_b = b;\n\n\treturn s;\n}\n\n// DOES NOT LOCK OR CHECK VALIDITY\n// Assumes caller has already done this\n// Wrapper for seccomp_rule_add_... functions\nfunc (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {\n\tvar length C.uint\n\tif cond != nil {\n\t\tlength = 1\n\t} else {\n\t\tlength = 0\n\t}\n\n\tvar retCode C.int\n\tif exact {\n\t\tretCode = C.seccomp_rule_add_exact_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t} else {\n\t\tretCode = C.seccomp_rule_add_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t}\n\n\tif syscall.Errno(-1*retCode) == syscall.EFAULT {\n\t\treturn fmt.Errorf(\"unrecognized syscall\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EPERM {\n\t\treturn fmt.Errorf(\"requested action matches default action of filter\")\n\t} else if retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// Generic add function for filter rules\nfunc (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tif len(conds) == 0 {\n\t\tif err := f.addRuleWrapper(call, action, exact, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// We don't support conditional filtering in library version v2.1\n\t\tif !checkVersionAbove(2, 2, 1) {\n\t\t\treturn VersionError{\n\t\t\t\tmessage: \"conditional filtering is not supported\",\n\t\t\t\tminimum: \"2.2.1\",\n\t\t\t}\n\t\t}\n\n\t\tfor _, cond := range conds {\n\t\t\tcmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))\n\t\t\tdefer C.free(cmpStruct)\n\n\t\t\tif err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n",
    "after_functions": "void* make_arg_cmp_array(unsigned int length)\n{\n        return calloc(length, sizeof(struct scmp_arg_cmp));\n}\n\n// Wrapper to add an scmp_arg_cmp struct to an existing arg_cmp array\nvoid add_struct_arg_cmp(\n                        struct scmp_arg_cmp* arr,\n                        unsigned int pos,\n                        unsigned int arg,\n                        int compare,\n                        uint64_t a,\n                        uint64_t b\n                       )\n{\n        arr[pos].arg = arg;\n        arr[pos].op = compare;\n        arr[pos].datum_a = a;\n        arr[pos].datum_b = b;\n\n        return;\n}\n\n// DOES NOT LOCK OR CHECK VALIDITY\n// Assumes caller has already done this\n// Wrapper for seccomp_rule_add_... functions\nfunc (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length C.uint, cond C.scmp_cast_t) error {\n\tif length != 0 && cond == nil {\n\t\treturn fmt.Errorf(\"null conditions list, but length is nonzero\")\n\t}\n\n\tvar retCode C.int\n\tif exact {\n\t\tretCode = C.seccomp_rule_add_exact_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t} else {\n\t\tretCode = C.seccomp_rule_add_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t}\n\n\tif syscall.Errno(-1*retCode) == syscall.EFAULT {\n\t\treturn fmt.Errorf(\"unrecognized syscall\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EPERM {\n\t\treturn fmt.Errorf(\"requested action matches default action of filter\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EINVAL {\n\t\treturn fmt.Errorf(\"two checks on same syscall argument\")\n\t} else if retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// Generic add function for filter rules\nfunc (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tif len(conds) == 0 {\n\t\tif err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// We don't support conditional filtering in library version v2.1\n\t\tif !checkVersionAbove(2, 2, 1) {\n\t\t\treturn VersionError{\n\t\t\t\tmessage: \"conditional filtering is not supported\",\n\t\t\t\tminimum: \"2.2.1\",\n\t\t\t}\n\t\t}\n\n\t\targsArr := C.make_arg_cmp_array(C.uint(len(conds)))\n\t\tif argsArr == nil {\n\t\t\treturn fmt.Errorf(\"error allocating memory for conditions\")\n\t\t}\n\t\tdefer C.free(argsArr)\n\n\t\tfor i, cond := range conds {\n\t\t\tC.add_struct_arg_cmp(C.scmp_cast_t(argsArr), C.uint(i),\n\t\t\t\tC.uint(cond.Argument), cond.Op.toNative(),\n\t\t\t\tC.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))\n\t\t}\n\n\t\tif err := f.addRuleWrapper(call, action, exact, C.uint(len(conds)), C.scmp_cast_t(argsArr)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
}