{
    "before_functions": "def redirect_to_auth_server(self, destination):\n    \"\"\"\n    Set a CSRF token in the session, and redirect to the IdP.\n    :param destination: the page that the user was going to,\n                        before we noticed they weren't logged in\n    :return: a redirect response\n    \"\"\"\n    csrf_token = b64encode(self.urandom(24)).decode('utf-8')\n    session['oidc_csrf_token'] = csrf_token\n    state = {\n        'csrf_token': csrf_token,\n        'destination': destination,\n    }\n    extra_params = {\n        'state': json.dumps(state),\n    }\n    flow = self.flow_for_request()\n    auth_url = '{url}&{extra_params}'.format(\n        url=flow.step1_get_authorize_url(),\n        extra_params=urlencode(extra_params))\n    # if the user has an ID token, it's invalid, or we wouldn't be here\n    self.set_cookie_id_token(None)\n    return redirect(auth_url)\n\ndef oidc_callback(self):\n    \"\"\"\n    Exchange the auth code for actual credentials,\n    then redirect to the originally requested page.\n    \"\"\"\n    # retrieve session and callback variables\n    try:\n        session_csrf_token = session.pop('oidc_csrf_token')\n\n        state = json.loads(request.args['state'])\n        csrf_token = state['csrf_token']\n        destination = state['destination']\n\n        code = request.args['code']\n    except (KeyError, ValueError):\n        logger.debug(\"Can't retrieve CSRF token, state, or code\",\n                     exc_info=True)\n        return self.oidc_error()\n\n    # check callback CSRF token passed to IdP\n    # against session CSRF token held by user\n    if csrf_token != session_csrf_token:\n        logger.debug(\"CSRF token mismatch\")\n        return self.oidc_error()\n\n    # make a request to IdP to exchange the auth code for OAuth credentials\n    flow = self.flow_for_request()\n    credentials = flow.step2_exchange(code, http=self.http)\n    id_token = credentials.id_token\n    if not self.is_id_token_valid(id_token):\n        logger.debug(\"Invalid ID token\")\n        if id_token.get('hd') != self.app.config['OIDC_GOOGLE_APPS_DOMAIN']:\n            return self.oidc_error(\n                \"You must log in with an account from the {0} domain.\"\n                .format(self.app.config['OIDC_GOOGLE_APPS_DOMAIN']),\n                self.WRONG_GOOGLE_APPS_DOMAIN)\n        return self.oidc_error()\n\n    # store credentials by subject\n    # when Google is the IdP, the subject is their G+ account number\n    self.credentials_store[id_token['sub']] = credentials\n\n    # set a persistent signed cookie containing the ID token\n    # and redirect to the final destination\n    # TODO: validate redirect destination\n    response = redirect(destination)\n    self.set_cookie_id_token(id_token)\n    return response\n",
    "after_functions": "def redirect_to_auth_server(self, destination):\n    \"\"\"\n    Set a CSRF token in the session, and redirect to the IdP.\n    :param destination: the page that the user was going to,\n                        before we noticed they weren't logged in\n    :return: a redirect response\n    \"\"\"\n    destination = self.destination_serializer.dumps(destination)\n    csrf_token = b64encode(self.urandom(24)).decode('utf-8')\n    session['oidc_csrf_token'] = csrf_token\n    state = {\n        'csrf_token': csrf_token,\n        'destination': destination,\n    }\n    extra_params = {\n        'state': json.dumps(state),\n    }\n    flow = self.flow_for_request()\n    auth_url = '{url}&{extra_params}'.format(\n        url=flow.step1_get_authorize_url(),\n        extra_params=urlencode(extra_params))\n    # if the user has an ID token, it's invalid, or we wouldn't be here\n    self.set_cookie_id_token(None)\n    return redirect(auth_url)\n\ndef oidc_callback(self):\n    \"\"\"\n    Exchange the auth code for actual credentials,\n    then redirect to the originally requested page.\n    \"\"\"\n    # retrieve session and callback variables\n    try:\n        session_csrf_token = session.pop('oidc_csrf_token')\n\n        state = json.loads(request.args['state'])\n        csrf_token = state['csrf_token']\n        destination = state['destination']\n\n        code = request.args['code']\n    except (KeyError, ValueError):\n        logger.debug(\"Can't retrieve CSRF token, state, or code\",\n                     exc_info=True)\n        return self.oidc_error()\n\n    # check callback CSRF token passed to IdP\n    # against session CSRF token held by user\n    if csrf_token != session_csrf_token:\n        logger.debug(\"CSRF token mismatch\")\n        return self.oidc_error()\n\n    # make a request to IdP to exchange the auth code for OAuth credentials\n    flow = self.flow_for_request()\n    credentials = flow.step2_exchange(code, http=self.http)\n    id_token = credentials.id_token\n    if not self.is_id_token_valid(id_token):\n        logger.debug(\"Invalid ID token\")\n        if id_token.get('hd') != self.app.config['OIDC_GOOGLE_APPS_DOMAIN']:\n            return self.oidc_error(\n                \"You must log in with an account from the {0} domain.\"\n                .format(self.app.config['OIDC_GOOGLE_APPS_DOMAIN']),\n                self.WRONG_GOOGLE_APPS_DOMAIN)\n        return self.oidc_error()\n\n    # store credentials by subject\n    # when Google is the IdP, the subject is their G+ account number\n    self.credentials_store[id_token['sub']] = credentials\n\n    # Check whether somebody messed with the destination\n    destination = destination\n    try:\n        response = redirect(self.destination_serializer.loads(destination))\n    except BadSignature:\n        logger.error('Destination signature did not match. Rogue IdP?')\n        response = redirect('/')\n\n    # set a persistent signed cookie containing the ID token\n    # and redirect to the final destination\n    self.set_cookie_id_token(id_token)\n    return response\n"
}