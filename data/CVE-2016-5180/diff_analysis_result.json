{
    "before_functions": "int ares_create_query(const char *name, int dnsclass, int type,\n                      unsigned short id, int rd, unsigned char **buf,\n                      int *buflen, int max_udp_size)\n{\n  int len;\n  unsigned char *q;\n  const char *p;\n\n  /* Set our results early, in case we bail out early with an error. */\n  *buflen = 0;\n  *buf = NULL;\n\n  /* Compute the length of the encoded name so we can check buflen.\n   * Start counting at 1 for the zero-length label at the end. */\n  len = 1;\n  for (p = name; *p; p++)\n    {\n      if (*p == '\\\\' && *(p + 1) != 0)\n        p++;\n      len++;\n    }\n  /* If there are n periods in the name, there are n + 1 labels, and\n   * thus n + 1 length fields, unless the name is empty or ends with a\n   * period.  So add 1 unless name is empty or ends with a period.\n   */\n  if (*name && *(p - 1) != '.')\n    len++;\n\n  /* Immediately reject names that are longer than the maximum of 255\n   * bytes that's specified in RFC 1035 (\"To simplify implementations,\n   * the total length of a domain name (i.e., label octets and label\n   * length octets) is restricted to 255 octets or less.\"). We aren't\n   * doing this just to be a stickler about RFCs. For names that are\n   * too long, 'dnscache' closes its TCP connection to us immediately\n   * (when using TCP) and ignores the request when using UDP, and\n   * BIND's named returns ServFail (TCP or UDP). Sending a request\n   * that we know will cause 'dnscache' to close the TCP connection is\n   * painful, since that makes any other outstanding requests on that\n   * connection fail. And sending a UDP request that we know\n   * 'dnscache' will ignore is bad because resources will be tied up\n   * until we time-out the request.\n   */\n  if (len > MAXCDNAME)\n    return ARES_EBADNAME;\n\n  *buflen = len + HFIXEDSZ + QFIXEDSZ + (max_udp_size ? EDNSFIXEDSZ : 0);\n  *buf = ares_malloc(*buflen);\n  if (!*buf)\n      return ARES_ENOMEM;\n\n  /* Set up the header. */\n  q = *buf;\n  memset(q, 0, HFIXEDSZ);\n  DNS_HEADER_SET_QID(q, id);\n  DNS_HEADER_SET_OPCODE(q, QUERY);\n  if (rd) {\n    DNS_HEADER_SET_RD(q, 1);\n  }\n  else {\n    DNS_HEADER_SET_RD(q, 0);\n  }\n  DNS_HEADER_SET_QDCOUNT(q, 1);\n\n  if (max_udp_size) {\n      DNS_HEADER_SET_ARCOUNT(q, 1);\n  }\n\n  /* A name of \".\" is a screw case for the loop below, so adjust it. */\n  if (strcmp(name, \".\") == 0)\n    name++;\n\n  /* Start writing out the name after the header. */\n  q += HFIXEDSZ;\n  while (*name)\n    {\n      if (*name == '.')\n        return ARES_EBADNAME;\n\n      /* Count the number of bytes in this label. */\n      len = 0;\n      for (p = name; *p && *p != '.'; p++)\n        {\n          if (*p == '\\\\' && *(p + 1) != 0)\n            p++;\n          len++;\n        }\n      if (len > MAXLABEL)\n        return ARES_EBADNAME;\n\n      /* Encode the length and copy the data. */\n      *q++ = (unsigned char)len;\n      for (p = name; *p && *p != '.'; p++)\n        {\n          if (*p == '\\\\' && *(p + 1) != 0)\n            p++;\n          *q++ = *p;\n        }\n\n      /* Go to the next label and repeat, unless we hit the end. */\n      if (!*p)\n        break;\n      name = p + 1;\n    }\n\n  /* Add the zero-length label at the end. */\n  *q++ = 0;\n\n  /* Finish off the question with the type and class. */\n  DNS_QUESTION_SET_TYPE(q, type);\n  DNS_QUESTION_SET_CLASS(q, dnsclass);\n\n  if (max_udp_size)\n  {\n      q += QFIXEDSZ;\n      memset(q, 0, EDNSFIXEDSZ);\n      q++;\n      DNS_RR_SET_TYPE(q, T_OPT);\n      DNS_RR_SET_CLASS(q, max_udp_size);\n  }\n\n  return ARES_SUCCESS;\n}\n",
    "after_functions": "int ares_create_query(const char *name, int dnsclass, int type,\n                      unsigned short id, int rd, unsigned char **bufp,\n                      int *buflenp, int max_udp_size)\n{\n  size_t len;\n  unsigned char *q;\n  const char *p;\n  size_t buflen;\n  unsigned char *buf;\n\n  /* Set our results early, in case we bail out early with an error. */\n  *buflenp = 0;\n  *bufp = NULL;\n\n  /* Allocate a memory area for the maximum size this packet might need. +2\n   * is for the length byte and zero termination if no dots or ecscaping is\n   * used.\n   */\n  len = strlen(name) + 2 + HFIXEDSZ + QFIXEDSZ +\n    (max_udp_size ? EDNSFIXEDSZ : 0);\n  buf = ares_malloc(len);\n  if (!buf)\n    return ARES_ENOMEM;\n\n  /* Set up the header. */\n  q = buf;\n  memset(q, 0, HFIXEDSZ);\n  DNS_HEADER_SET_QID(q, id);\n  DNS_HEADER_SET_OPCODE(q, QUERY);\n  if (rd) {\n    DNS_HEADER_SET_RD(q, 1);\n  }\n  else {\n    DNS_HEADER_SET_RD(q, 0);\n  }\n  DNS_HEADER_SET_QDCOUNT(q, 1);\n\n  if (max_udp_size) {\n      DNS_HEADER_SET_ARCOUNT(q, 1);\n  }\n\n  /* A name of \".\" is a screw case for the loop below, so adjust it. */\n  if (strcmp(name, \".\") == 0)\n    name++;\n\n  /* Start writing out the name after the header. */\n  q += HFIXEDSZ;\n  while (*name)\n    {\n      if (*name == '.') {\n        free (buf);\n        return ARES_EBADNAME;\n      }\n\n      /* Count the number of bytes in this label. */\n      len = 0;\n      for (p = name; *p && *p != '.'; p++)\n        {\n          if (*p == '\\\\' && *(p + 1) != 0)\n            p++;\n          len++;\n        }\n      if (len > MAXLABEL) {\n        free (buf);\n        return ARES_EBADNAME;\n      }\n\n      /* Encode the length and copy the data. */\n      *q++ = (unsigned char)len;\n      for (p = name; *p && *p != '.'; p++)\n        {\n          if (*p == '\\\\' && *(p + 1) != 0)\n            p++;\n          *q++ = *p;\n        }\n\n      /* Go to the next label and repeat, unless we hit the end. */\n      if (!*p)\n        break;\n      name = p + 1;\n    }\n\n  /* Add the zero-length label at the end. */\n  *q++ = 0;\n\n  /* Finish off the question with the type and class. */\n  DNS_QUESTION_SET_TYPE(q, type);\n  DNS_QUESTION_SET_CLASS(q, dnsclass);\n\n  q += QFIXEDSZ;\n  if (max_udp_size)\n  {\n      memset(q, 0, EDNSFIXEDSZ);\n      q++;\n      DNS_RR_SET_TYPE(q, T_OPT);\n      DNS_RR_SET_CLASS(q, max_udp_size);\n      q += (EDNSFIXEDSZ-1);\n  }\n  buflen = (q - buf);\n\n  /* Reject names that are longer than the maximum of 255 bytes that's\n   * specified in RFC 1035 (\"To simplify implementations, the total length of\n   * a domain name (i.e., label octets and label length octets) is restricted\n   * to 255 octets or less.\"). */\n  if (buflen > (MAXCDNAME + HFIXEDSZ + QFIXEDSZ +\n                (max_udp_size ? EDNSFIXEDSZ : 0))) {\n    free (buf);\n    return ARES_EBADNAME;\n  }\n\n  /* we know this fits in an int at this point */\n  *buflenp = (int) buflen;\n  *bufp = buf;\n\n  return ARES_SUCCESS;\n}\n"
}