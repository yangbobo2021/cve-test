{
    "before_functions": "def url(tgpath, tgparams=None, **kwargs):\n    '''Computes URLs.\n\n    This is a replacement for :func:`turbogears.controllers.url` (aka\n    :func:`tg.url` in the template).  In addition to the functionality that\n    :func:`tg.url` provides, it adds a token to prevent :term:`CSRF` attacks.\n\n    :arg tgpath:  a list or a string. If the path is absolute (starts\n        with a \"/\"), the :attr:`server.webpath`, :envvar:`SCRIPT_NAME` and\n        the approot of the application are prepended to the path. In order for\n        the approot to be detected properly, the root object should extend\n        :class:`turbogears.controllers.RootController`.\n    :kwarg tgparams: See param: ``kwargs``\n    :kwarg kwargs: Query parameters for the URL can be passed in as a\n        dictionary in the second argument *or* as keyword parameters.\n        Values which are a list or a tuple are used to create multiple\n        key-value pairs.\n    :returns: The changed path\n\n    .. versionadded:: 0.3.10\n       Modified from turbogears.controllers.url for :ref:`CSRF-Protection`\n    '''\n    if not isinstance(tgpath, six.string_types):\n        tgpath = '/'.join(list(tgpath))\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):  # pylint: disable-msg=W0704\n                # :W0704: Lack of wsgi environ is fine... we still have\n                # server.webpath\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kwargs\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kwargs)\n        except AttributeError:\n            raise TypeError(\n                'url() expects a dictionary for query parameters')\n    args = []\n    # Add the _csrf_token\n    try:\n        if identity.current.csrf_token:\n            tgparams.update({'_csrf_token': identity.current.csrf_token})\n    except RequestRequiredException:  # pylint: disable-msg=W0704\n        # :W0704: If we are outside of a request (called from non-controller\n        # methods/ templates) just don't set the _csrf_token.\n        pass\n\n    # Check for query params in the current url\n    query_params = six.iteritems(tgparams)\n    scheme, netloc, path, params, query_s, fragment = urlparse(tgpath)\n    if query_s:\n        query_params = chain((p for p in cgi.parse_qsl(query_s) if p[0] !=\n                              '_csrf_token'), query_params)\n\n    for key, value in query_params:\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for key, value in pairs:\n            if value is None:\n                continue\n            if isinstance(value, unicode):\n                value = value.encode('utf8')\n            args.append((key, str(value)))\n    query_string = urlencode(args, True)\n    tgpath = urlunparse((scheme, netloc, path, params, query_string, fragment))\n    return tgpath\n",
    "after_functions": "def url(tgpath, tgparams=None, **kwargs):\n    '''Computes URLs.\n\n    This is a replacement for :func:`turbogears.controllers.url` (aka\n    :func:`tg.url` in the template).  In addition to the functionality that\n    :func:`tg.url` provides, it adds a token to prevent :term:`CSRF` attacks.\n\n    :arg tgpath:  a list or a string. If the path is absolute (starts\n        with a \"/\"), the :attr:`server.webpath`, :envvar:`SCRIPT_NAME` and\n        the approot of the application are prepended to the path. In order for\n        the approot to be detected properly, the root object should extend\n        :class:`turbogears.controllers.RootController`.\n    :kwarg tgparams: See param: ``kwargs``\n    :kwarg kwargs: Query parameters for the URL can be passed in as a\n        dictionary in the second argument *or* as keyword parameters.\n        Values which are a list or a tuple are used to create multiple\n        key-value pairs.\n    :returns: The changed path\n\n    .. versionadded:: 0.3.10\n       Modified from turbogears.controllers.url for :ref:`CSRF-Protection`\n    '''\n    if not isinstance(tgpath, six.string_types):\n        tgpath = '/'.join(list(tgpath))\n    if not tgpath.startswith('/'):\n        # Do not allow the url() function to be used for external urls.\n        # This function is primarily used in redirect() calls, so this prevents\n        # covert redirects and thus CSRF leaking.\n        tgpath = '/'\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):  # pylint: disable-msg=W0704\n                # :W0704: Lack of wsgi environ is fine... we still have\n                # server.webpath\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kwargs\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kwargs)\n        except AttributeError:\n            raise TypeError(\n                'url() expects a dictionary for query parameters')\n    args = []\n    # Add the _csrf_token\n    try:\n        if identity.current.csrf_token:\n            tgparams.update({'_csrf_token': identity.current.csrf_token})\n    except RequestRequiredException:  # pylint: disable-msg=W0704\n        # :W0704: If we are outside of a request (called from non-controller\n        # methods/ templates) just don't set the _csrf_token.\n        pass\n\n    # Check for query params in the current url\n    query_params = six.iteritems(tgparams)\n    scheme, netloc, path, params, query_s, fragment = urlparse(tgpath)\n    if query_s:\n        query_params = chain((p for p in cgi.parse_qsl(query_s) if p[0] !=\n                              '_csrf_token'), query_params)\n\n    for key, value in query_params:\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for key, value in pairs:\n            if value is None:\n                continue\n            if isinstance(value, unicode):\n                value = value.encode('utf8')\n            args.append((key, str(value)))\n    query_string = urlencode(args, True)\n    tgpath = urlunparse((scheme, netloc, path, params, query_string, fragment))\n    return tgpath\n"
}