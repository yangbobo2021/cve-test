{
    "before_functions": "def __call__(self, env, start_response):\n    try:\n        # Validate the method\n        method = env[\"REQUEST_METHOD\"].upper()\n        if method != \"POST\":\n            raise HTTPException(405, \"Method not allowed (%s).\" % method)\n\n        # Parse the request\n        try:\n            length = int(env[\"CONTENT_LENGTH\"])\n        except AttributeError:\n            length = -1\n        try:\n            pr = codec.decode(env[\"wsgi.input\"].read(length))\n        except codec.ParsingError as e:\n            raise HTTPException(400, e.message)\n\n        # Find the remote proxy\n        servers = self.__resolver.lookup(\n            pr.realm,\n            kpasswd=isinstance(pr, codec.KPASSWDProxyRequest)\n        )\n        if not servers:\n            raise HTTPException(503, \"Can't find remote (%s).\" % pr)\n\n        # Contact the remote server\n        reply = None\n        wsocks = []\n        rsocks = []\n        for server in map(urlparse.urlparse, servers):\n            # Enforce valid, supported URIs\n            scheme = server.scheme.lower().split(\"+\", 1)\n            if scheme[0] not in (\"kerberos\", \"kpasswd\"):\n                continue\n            if len(scheme) > 1 and scheme[1] not in (\"tcp\", \"udp\"):\n                continue\n\n            # Do the DNS lookup\n            try:\n                port = server.port\n                if port is None:\n                    port = scheme[0]\n                addrs = socket.getaddrinfo(server.hostname, port)\n            except socket.gaierror:\n                continue\n\n            # Sort addresses so that we get TCP first.\n            #\n            # Stick a None address on the end so we can get one\n            # more attempt after all servers have been contacted.\n            addrs = tuple(sorted(filter(self.__filter_addr, addrs)))\n            for addr in addrs + (None,):\n                if addr is not None:\n                    # Bypass unspecified socktypes\n                    if (len(scheme) > 1\n                            and addr[1] != self.SOCKTYPES[scheme[1]]):\n                        continue\n\n                    # Create the socket\n                    sock = socket.socket(*addr[:3])\n                    sock.setblocking(0)\n\n                    # Connect\n                    try:\n                        # In Python 2.x, non-blocking connect() throws\n                        # socket.error() with errno == EINPROGRESS. In\n                        # Python 3.x, it throws io.BlockingIOError().\n                        sock.connect(addr[4])\n                    except socket.error as e:\n                        if e.errno != 115:  # errno != EINPROGRESS\n                            sock.close()\n                            continue\n                    except io.BlockingIOError:\n                        pass\n                    wsocks.append(sock)\n\n                # Resend packets to UDP servers\n                for sock in tuple(rsocks):\n                    if self.sock_type(sock) == socket.SOCK_DGRAM:\n                        wsocks.append(sock)\n                        rsocks.remove(sock)\n\n                # Call select()\n                timeout = time.time() + (15 if addr is None else 2)\n                reply = self.__await_reply(pr, rsocks, wsocks, timeout)\n                if reply is not None:\n                    break\n\n            if reply is not None:\n                break\n\n        for sock in rsocks + wsocks:\n            sock.close()\n\n        if reply is None:\n            raise HTTPException(503, \"Remote unavailable (%s).\" % pr)\n\n        # Return the result to the client\n        raise HTTPException(200, codec.encode(reply),\n                            [(\"Content-Type\", \"application/kerberos\")])\n    except HTTPException as e:\n        start_response(str(e), e.headers)\n        return [e.message]\n",
    "after_functions": "def __call__(self, env, start_response):\n    try:\n        # Validate the method\n        method = env[\"REQUEST_METHOD\"].upper()\n        if method != \"POST\":\n            raise HTTPException(405, \"Method not allowed (%s).\" % method)\n\n        # Parse the request\n        try:\n            length = int(env[\"CONTENT_LENGTH\"])\n        except AttributeError:\n            raise HTTPException(411, \"Length required.\")\n        if length < 0:\n            raise HTTPException(411, \"Length required.\")\n        if length > self.MAX_LENGTH:\n            raise HTTPException(413, \"Request entity too large.\")\n        try:\n            pr = codec.decode(env[\"wsgi.input\"].read(length))\n        except codec.ParsingError as e:\n            raise HTTPException(400, e.message)\n\n        # Find the remote proxy\n        servers = self.__resolver.lookup(\n            pr.realm,\n            kpasswd=isinstance(pr, codec.KPASSWDProxyRequest)\n        )\n        if not servers:\n            raise HTTPException(503, \"Can't find remote (%s).\" % pr)\n\n        # Contact the remote server\n        reply = None\n        wsocks = []\n        rsocks = []\n        for server in map(urlparse.urlparse, servers):\n            # Enforce valid, supported URIs\n            scheme = server.scheme.lower().split(\"+\", 1)\n            if scheme[0] not in (\"kerberos\", \"kpasswd\"):\n                continue\n            if len(scheme) > 1 and scheme[1] not in (\"tcp\", \"udp\"):\n                continue\n\n            # Do the DNS lookup\n            try:\n                port = server.port\n                if port is None:\n                    port = scheme[0]\n                addrs = socket.getaddrinfo(server.hostname, port)\n            except socket.gaierror:\n                continue\n\n            # Sort addresses so that we get TCP first.\n            #\n            # Stick a None address on the end so we can get one\n            # more attempt after all servers have been contacted.\n            addrs = tuple(sorted(filter(self.__filter_addr, addrs)))\n            for addr in addrs + (None,):\n                if addr is not None:\n                    # Bypass unspecified socktypes\n                    if (len(scheme) > 1\n                            and addr[1] != self.SOCKTYPES[scheme[1]]):\n                        continue\n\n                    # Create the socket\n                    sock = socket.socket(*addr[:3])\n                    sock.setblocking(0)\n\n                    # Connect\n                    try:\n                        # In Python 2.x, non-blocking connect() throws\n                        # socket.error() with errno == EINPROGRESS. In\n                        # Python 3.x, it throws io.BlockingIOError().\n                        sock.connect(addr[4])\n                    except socket.error as e:\n                        if e.errno != 115:  # errno != EINPROGRESS\n                            sock.close()\n                            continue\n                    except io.BlockingIOError:\n                        pass\n                    wsocks.append(sock)\n\n                # Resend packets to UDP servers\n                for sock in tuple(rsocks):\n                    if self.sock_type(sock) == socket.SOCK_DGRAM:\n                        wsocks.append(sock)\n                        rsocks.remove(sock)\n\n                # Call select()\n                timeout = time.time() + (15 if addr is None else 2)\n                reply = self.__await_reply(pr, rsocks, wsocks, timeout)\n                if reply is not None:\n                    break\n\n            if reply is not None:\n                break\n\n        for sock in rsocks + wsocks:\n            sock.close()\n\n        if reply is None:\n            raise HTTPException(503, \"Remote unavailable (%s).\" % pr)\n\n        # Return the result to the client\n        raise HTTPException(200, codec.encode(reply),\n                            [(\"Content-Type\", \"application/kerberos\")])\n    except HTTPException as e:\n        start_response(str(e), e.headers)\n        return [e.message]\n"
}