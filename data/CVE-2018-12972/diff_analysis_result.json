{
    "before_functions": "public ExpressionDataPoint[] next(final long timestamp) {\n    \n    // fetch the timestamp ONCE to save some cycles.\n    // final long timestamp = iterator.nextTimestamp();\n    iterator.next();\n    \n    // set aside a couple of addresses for the variables\n    double val;\n    double result;\n    for (int i = 0; i < iterator.getSeriesSize(); i++) {\n      // this here is why life sucks. there MUST be a better way to bind variables\n      for (final String variable : names) {\n        if (iteration_results.get(variable)[i] == null) {\n          context.set(variable, results.get(variable).getFillPolicy().getValue());\n        } else {\n          val = iteration_results.get(variable)[i].toDouble();\n          if (Double.isNaN(val)) {\n            context.set(variable, results.get(variable).getFillPolicy().getValue());\n          } else {\n            context.set(variable, val);\n          }\n        }\n      }\n      final Object output = expression.execute(context);\n      if (output instanceof Double) {\n        result = (Double) expression.execute(context);\n      } else if (output instanceof Boolean) {\n        result = (((Boolean) expression.execute(context)) ? 1 : 0);\n      } else {\n        throw new IllegalStateException(\"Expression returned a result of type: \" \n            + output.getClass().getName() + \" for \" + this);\n      }\n      dps[i].reset(timestamp, result);\n    }\n    return dps;\n  }\n\n@Override\npublic void next(final int i) {\n    iterator.next(i);\n    \n    // set aside a couple of addresses for the variables\n    double val;\n    double result;\n    // this here is why life sucks. there MUST be a better way to bind variables\n    long ts = Long.MAX_VALUE;\n    for (final String variable : names) {\n      if (iteration_results.get(variable)[i] == null) {\n        context.set(variable, results.get(variable).getFillPolicy().getValue());\n      } else {\n        if (iteration_results.get(variable)[i].timestamp() < ts) {\n          ts = iteration_results.get(variable)[i].timestamp();\n        }\n        val = iteration_results.get(variable)[i].toDouble();\n        if (Double.isNaN(val)) {\n          context.set(variable, results.get(variable).getFillPolicy().getValue());\n        } else {\n          context.set(variable, val);\n        }\n      }\n    }\n    result = (Double)expression.execute(context);\n    dps[i].reset(ts, result);\n  }\n",
    "after_functions": "public ExpressionDataPoint[] next(final long timestamp) {\n    \n    // fetch the timestamp ONCE to save some cycles.\n    // final long timestamp = iterator.nextTimestamp();\n    iterator.next();\n    \n    // set aside a couple of addresses for the variables\n    double val;\n    double result;\n    for (int i = 0; i < iterator.getSeriesSize(); i++) {\n      // this here is why life sucks. there MUST be a better way to bind variables\n      for (final String variable : names) {\n        if (iteration_results.get(variable)[i] == null) {\n          context.set(variable, results.get(variable).getFillPolicy().getValue());\n        } else {\n          val = iteration_results.get(variable)[i].toDouble();\n          if (Double.isNaN(val)) {\n            context.set(variable, results.get(variable).getFillPolicy().getValue());\n          } else {\n            context.set(variable, val);\n          }\n        }\n      }\n      final Object output = expression.execute(context);\n      if (output instanceof Double) {\n        result = (Double) output;\n      } else if (output instanceof Boolean) {\n        result = (((Boolean) output) ? 1 : 0);\n      } else {\n        throw new IllegalStateException(\"Expression returned a result of type: \" \n            + output.getClass().getName() + \" for \" + this);\n      }\n      dps[i].reset(timestamp, result);\n    }\n    return dps;\n  }\n\n@Override\npublic void next(final int i) {\n    iterator.next(i);\n    \n    // set aside a couple of addresses for the variables\n    double val;\n    double result;\n    // this here is why life sucks. there MUST be a better way to bind variables\n    long ts = Long.MAX_VALUE;\n    for (final String variable : names) {\n      if (iteration_results.get(variable)[i] == null) {\n        context.set(variable, results.get(variable).getFillPolicy().getValue());\n      } else {\n        if (iteration_results.get(variable)[i].timestamp() < ts) {\n          ts = iteration_results.get(variable)[i].timestamp();\n        }\n        val = iteration_results.get(variable)[i].toDouble();\n        if (Double.isNaN(val)) {\n          context.set(variable, results.get(variable).getFillPolicy().getValue());\n        } else {\n          context.set(variable, val);\n        }\n      }\n    }\n    final Object output = expression.execute(context);\n    if (output instanceof Double) {\n      result = (Double) output;\n    } else if (output instanceof Boolean) {\n      result = (((Boolean) output) ? 1 : 0);\n    } else {\n      throw new IllegalStateException(\"Expression returned a result of type: \" \n          + output.getClass().getName() + \" for \" + this);\n    }\n    dps[i].reset(ts, result);\n  }\n"
}