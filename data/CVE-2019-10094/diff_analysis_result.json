{
    "before_functions": "@Override\npublic void parse(InputStream stream, ContentHandler recursiveParserWrapperHandler,\n        Metadata metadata, ParseContext context) throws IOException,\n        SAXException, TikaException {\n    //this tracks the state of the parent parser, per call to #parse\n    //in future versions, we can remove lastParseState, and this will be thread-safe\n    ParserState parserState;\n    if (recursiveParserWrapperHandler instanceof AbstractRecursiveParserWrapperHandler) {\n        parserState = new ParserState((AbstractRecursiveParserWrapperHandler)recursiveParserWrapperHandler);\n    } else {\n        parserState = new ParserState(new RecursiveParserWrapperHandler(contentHandlerFactory, maxEmbeddedResources));\n        lastParseState = parserState;\n    }\n    EmbeddedParserDecorator decorator = new EmbeddedParserDecorator(getWrappedParser(), \"/\", parserState);\n    context.set(Parser.class, decorator);\n    ContentHandler localHandler = parserState.recursiveParserWrapperHandler.getNewContentHandler();\n    long started = System.currentTimeMillis();\n    parserState.recursiveParserWrapperHandler.startDocument();\n    try {\n        getWrappedParser().parse(stream, localHandler, metadata, context);\n    } catch (SAXException e) {\n        boolean wlr = isWriteLimitReached(e);\n        if (wlr == false) {\n            throw e;\n        }\n        metadata.set(RecursiveParserWrapperHandler.WRITE_LIMIT_REACHED, \"true\");\n    } catch (Throwable e) {\n        //try our best to record the problem in the metadata object\n        //then rethrow\n        String stackTrace = ExceptionUtils.getFilteredStackTrace(e);\n        metadata.add(TikaCoreProperties.TIKA_META_EXCEPTION_PREFIX+\"runtime\", stackTrace);\n        throw e;\n    } finally {\n        long elapsedMillis = System.currentTimeMillis() - started;\n        metadata.set(RecursiveParserWrapperHandler.PARSE_TIME_MILLIS, Long.toString(elapsedMillis));\n        parserState.recursiveParserWrapperHandler.endDocument(localHandler, metadata);\n        parserState.recursiveParserWrapperHandler.endDocument();\n    }\n}\n",
    "after_functions": "@Override\npublic void parse(InputStream stream, ContentHandler recursiveParserWrapperHandler,\n        Metadata metadata, ParseContext context) throws IOException,\n        SAXException, TikaException {\n    //this tracks the state of the parent parser, per call to #parse\n    //in future versions, we can remove lastParseState, and this will be thread-safe\n    ParserState parserState;\n    if (recursiveParserWrapperHandler instanceof AbstractRecursiveParserWrapperHandler) {\n        parserState = new ParserState((AbstractRecursiveParserWrapperHandler)recursiveParserWrapperHandler);\n    } else {\n        parserState = new ParserState(new RecursiveParserWrapperHandler(contentHandlerFactory, maxEmbeddedResources));\n        lastParseState = parserState;\n    }\n    EmbeddedParserDecorator decorator = new EmbeddedParserDecorator(getWrappedParser(), \"/\", parserState);\n    context.set(Parser.class, decorator);\n    ContentHandler localHandler = parserState.recursiveParserWrapperHandler.getNewContentHandler();\n    long started = System.currentTimeMillis();\n    parserState.recursiveParserWrapperHandler.startDocument();\n    try {\n        try (TikaInputStream tis = TikaInputStream.get(stream)) {\n            RecursivelySecureContentHandler secureContentHandler =\n                    new RecursivelySecureContentHandler(localHandler, tis);\n            context.set(RecursivelySecureContentHandler.class, secureContentHandler);\n            getWrappedParser().parse(tis, secureContentHandler, metadata, context);\n        }\n    } catch (SAXException e) {\n        boolean wlr = isWriteLimitReached(e);\n        if (wlr == false) {\n            throw e;\n        }\n        metadata.set(RecursiveParserWrapperHandler.WRITE_LIMIT_REACHED, \"true\");\n    } catch (Throwable e) {\n        //try our best to record the problem in the metadata object\n        //then rethrow\n        String stackTrace = ExceptionUtils.getFilteredStackTrace(e);\n        metadata.add(TikaCoreProperties.TIKA_META_EXCEPTION_PREFIX+\"runtime\", stackTrace);\n        throw e;\n    } finally {\n        long elapsedMillis = System.currentTimeMillis() - started;\n        metadata.set(RecursiveParserWrapperHandler.PARSE_TIME_MILLIS, Long.toString(elapsedMillis));\n        parserState.recursiveParserWrapperHandler.endDocument(localHandler, metadata);\n        parserState.recursiveParserWrapperHandler.endDocument();\n    }\n}\n"
}