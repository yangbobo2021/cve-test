import os
import json
import openai
from datetime import datetime
import logging
import re

def setup_logging():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"rule_generation_{timestamp}.log"
    
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.INFO)
    
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def call_llm(messages):
    try:
        client = openai.OpenAI(
            api_key=os.environ["OPENAI_API_KEY"],
            base_url=os.environ["OPENAI_API_BASE"]
        )
        response = client.chat.completions.create(
            model="claude-3-5-sonnet",
            messages=messages
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"Exception in call_llm: {str(e)}")
        return None

def get_all_files(directory):
    file_list = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_list.append(os.path.relpath(os.path.join(root, file), directory))
    return file_list

def generate_rule(before_code, after_code, logger):
    prompt = f"""Analyze the following code changes and generate a general rule for code optimization that can be applied to various projects:

Before:
{before_code}

After:
{after_code}

Please provide a general rule that:
1. Describes the type of improvement made
2. Explains why this change is beneficial
3. Suggests how to identify similar opportunities in other codebases
4. Does not include specific code or business logic from the example

The rule should be applicable across different projects and programming languages.

Important: Enclose your response in a Markdown code block (```). Do not use any language specifier after the opening ```.
"""

    messages = [{"role": "user", "content": prompt}]
    response = call_llm(messages)

    logger.info(f"Generated rule:\n{response}")
    return response

def extract_markdown_block(text):
    pattern = r'```(.*?)```'
    match = re.search(pattern, text, re.DOTALL)
    if match:
        return match.group(1).strip()
    return text  # Return original text if no markdown block found

def process_case(case_path, logger):
    before_path = os.path.join(case_path, 'before')
    after_path = os.path.join(case_path, 'after')
    
    before_files = get_all_files(before_path)
    after_files = get_all_files(after_path)
    
    if not before_files or not after_files:
        logger.error(f"No files found in before or after directory for case: {case_path}")
        return None

    before_file = before_files[0]
    after_file = after_files[0]
    
    before_code_path = os.path.join(before_path, before_file)
    after_code_path = os.path.join(after_path, after_file)

    logger.info(f"Processing case: {case_path}")

    with open(before_code_path, 'r', encoding='utf-8') as file:
        before_code = file.read()
    
    with open(after_code_path, 'r', encoding='utf-8') as file:
        after_code = file.read()

    rule_response = generate_rule(before_code, after_code, logger)
    rule = extract_markdown_block(rule_response)

    return {
        'general_rule': rule
    }

def main():
    logger = setup_logging()
    logger.info("Starting rule generation process")

    with open('small_file_cases.json', 'r') as f:
        cases = json.load(f)

    for case in cases:
        try:
            case_result = process_case(case, logger)
            if case_result:
                result_file_path = os.path.join(case, 'general_rule.json')
                
                with open(result_file_path, 'w') as f:
                    json.dump(case_result, f, indent=4)
                
                logger.info(f"Rule written to {result_file_path}")
            
        except Exception as e:
            logger.error(f"Error processing case {case}: {str(e)}")

    logger.info("Rule generation process completed")

if __name__ == "__main__":
    main()