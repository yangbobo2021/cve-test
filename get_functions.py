import os
import json
import openai
from datetime import datetime
import logging
import re

def setup_logging():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"code_diff_analysis_{timestamp}.log"
    
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.INFO)
    
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def call_llm(messages):
    try:
        client = openai.OpenAI(
            api_key=os.environ["OPENAI_API_KEY"],
            base_url=os.environ["OPENAI_API_BASE"]
        )
        response = client.chat.completions.create(
            model="claude-3-5-sonnet",
            messages=messages
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"Exception in call_llm: {str(e)}")
        return None

def extract_code_blocks(response):
    code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', response, re.DOTALL)
    return code_blocks

def is_source_code_file(filename):
    source_code_extensions = ['.py', '.java', '.cpp', '.c', '.js', '.ts', '.go', '.rb', '.php', '.cs']
    return any(filename.endswith(ext) for ext in source_code_extensions)

def get_all_files(directory):
    file_list = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_list.append(os.path.relpath(os.path.join(root, file), directory))
    return file_list

def process_case(case_path, logger):
    before_path = os.path.join(case_path, 'before')
    after_path = os.path.join(case_path, 'after')
    
    before_files = get_all_files(before_path)
    after_files = get_all_files(after_path)
    
    if not before_files or not after_files:
        logger.error(f"No files found in before or after directory for case: {case_path}")
        return None

    before_file = before_files[0]
    after_file = after_files[0]
    
    before_code_path = os.path.join(before_path, before_file)
    after_code_path = os.path.join(after_path, after_file)

    logger.info(f"Processing case: {case_path}")

    # Skip non-code files
    if not is_source_code_file(before_file) or not is_source_code_file(after_file):
        logger.info(f"Skipping non-source code file: {before_file}")
        return None

    with open(before_code_path, 'r', encoding='utf-8') as file:
        before_code = file.read()
    
    with open(after_code_path, 'r', encoding='utf-8') as file:
        after_code = file.read()

    prompt = f"""Compare the following two versions of code and identify the functions or methods that have been modified:

Before:
{before_code}

After:
{after_code}

Please output the complete modified functions or methods in two markdown code blocks. The first block should contain the function(s) or method(s) from the 'Before' code, and the second block should contain the corresponding function(s) or method(s) from the 'After' code. Include only the modified parts.

Important: Provide the complete code for each function or method. Do not use ellipsis (...) or any other form of abbreviation. Each function or method should be shown in its entirety."""

    messages = [{"role": "user", "content": prompt}]
    response = call_llm(messages)

    # Log the AI's response
    logger.info(f"AI Response for case {case_path}:\n{response}")

    code_blocks = extract_code_blocks(response)
    
    if len(code_blocks) != 2:
        logger.error(f"Expected 2 code blocks, but got {len(code_blocks)}")
        return None

    return {
        'before_functions': code_blocks[0],
        'after_functions': code_blocks[1]
    }

def main():
    logger = setup_logging()
    logger.info("Starting code diff analysis process")

    with open('small_file_cases.json', 'r') as f:
        cases = json.load(f)

    for case in cases:
        try:
            case_result = process_case(case, logger)
            if case_result:
                # 创建结果文件路径
                result_file_path = os.path.join(case, 'diff_analysis_result.json')
                
                # 将结果写入到用例目录中
                with open(result_file_path, 'w') as f:
                    json.dump(case_result, f, indent=4)
                
                logger.info(f"Result written to {result_file_path}")
            
        except Exception as e:
            logger.error(f"Error processing case {case}: {str(e)}")

    logger.info("Code diff analysis process completed")

if __name__ == "__main__":
    main()