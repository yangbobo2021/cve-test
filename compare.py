import os
import json
import openai
from datetime import datetime
import logging

def setup_logging():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"security_analysis_{timestamp}.log"
    
    # 创建一个logger
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # 创建文件处理器
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.INFO)
    
    # 创建控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # 创建格式化器
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    # 将格式化器添加到处理器
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # 将处理器添加到logger
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def call_llm(messages):
    try:
        client = openai.OpenAI(
            api_key=os.environ["OPENAI_API_KEY"],
            base_url=os.environ["OPENAI_API_BASE"]
        )
        response = client.chat.completions.create(
            model="claude-3-5-sonnet",
            messages=messages
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"Exception in call_llm: {str(e)}")
        return None

def parse_json(response):
    try:
        if response.find("```json") >= 0:
            start_pos = response.find("```json") + 7
            end_pos = response.rfind("```")
            response = response[start_pos:end_pos]
        else:
            start_pos = response.find("{")
            end_pos = response.rfind("}")
            response = response[start_pos:end_pos+1]
        return json.loads(response, strict=False)
    except Exception as e:
        print("Exception:", str(e))
        raise e
    
def analyze_before_code(code_path):
    with open(code_path, 'r', encoding='utf-8') as file:
        code = file.read()
    
    prompt = f"""Please analyze the following code and identify exactly 3 most severe security risks:

{code}

List exactly 3 security risks, no more and no less:"""
    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def analyze_after_code(code_path, before_risks):
    with open(code_path, 'r', encoding='utf-8') as file:
        code = file.read()
    
    prompt = f"""Given the following code and the previously identified security risks:

Previously identified risks:
{before_risks}

Code to analyze:
{code}

Please check if the previously identified security risks still exist in this code. For each risk, state whether it has been fully addressed or still exists. Do not use 'partially addressed'. Provide a brief explanation for each:"""

    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def get_all_files(directory):
    file_list = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_list.append(os.path.relpath(os.path.join(root, file), directory))
    return file_list

def process_case(case_path, logger):
    before_path = os.path.join(case_path, 'before')
    after_path = os.path.join(case_path, 'after')
    
    before_file = get_all_files(before_path)[0]
    after_file = get_all_files(after_path)[0]
    
    before_code_path = os.path.join(before_path, before_file)
    after_code_path = os.path.join(after_path, after_file)

    logger.info(f"Processing case: {case_path}")

    # Step 1 & 2: Analyze before code and log results
    logger.info("Analyzing before code...")
    before_analysis = analyze_before_code(before_code_path)
    logger.info(f"Before analysis result:\n{before_analysis}")

    # Step 3: Analyze after code
    logger.info("Analyzing after code...")
    after_analysis = analyze_after_code(after_code_path, before_analysis)
    logger.info(f"After analysis result:\n{after_analysis}")

    # Step 4: Generate final JSON output
    final_prompt = f"""Based on the following analyses, please generate a JSON output summarizing the findings:

Before code analysis:
{before_analysis}

After code analysis:
{after_analysis}

Generate a JSON with the following structure:
{{
    "before_risks": [list of identified risks],
    "after_analysis": {{
        "risk1": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }},
        "risk2": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }},
        "risk3": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }}
    }},
    "overall_assessment": "overall security improvement assessment"
}}
"""
    messages = [{"role": "user", "content": final_prompt}]
    final_result = call_llm(messages)
    final_result = parse_json(final_result)
    print("final json result:", final_result)
    if not final_result:
        logger.error(f"Final JSON result:\n{final_result}")
    logger.info(f"Final JSON result:\n{final_result}")

    return final_result

def analyze_final_result(final_result):
    remaining_risks = 0
    for risk in final_result['after_analysis'].values():
        if risk['status'] == 'still_exists':
            remaining_risks += 1
    return remaining_risks

def main():
    logger = setup_logging()
    logger.info("Starting security analysis process")

    with open('small_file_cases.json', 'r') as f:
        cases = json.load(f)

    results = {}
    total_cases = 0
    fixed_cases = 0
    
    for case in cases:
        try:
            case_result = process_case(case, logger)
            results[case] = case_result
            
            # 分析最终结果
            remaining_risks = analyze_final_result(case_result)
            logger.info(f"Case {case}: {remaining_risks} out of 3 risks still exist")
            
            # 更新计数器
            total_cases += 1
            if remaining_risks < 3:
                fixed_cases += 1
            
            # 将剩余风险数添加到结果中
            results[case]['remaining_risks'] = remaining_risks
            
            # 输出当前总执行用例数和存在问题被修复的用例数
            logger.info(f"Total cases executed: {total_cases}, Cases with all risks fixed: {fixed_cases}")
            
        except Exception as e:
            logger.error(f"Error processing case {case}: {str(e)}")

    with open('security_analysis_results.json', 'w') as f:
        json.dump(results, f, indent=4)

    logger.info("Security analysis process completed")

if __name__ == "__main__":
    main()