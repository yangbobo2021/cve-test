import os
import yaml
import subprocess
import json
import shutil

TASK_STATE_FILE = 'task_state.json'

def find_config_files(base_dir):
    config_files = []
    print(f"Searching for config files in {base_dir}...")
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            if file == 'statement.yaml':
                config_files.append(os.path.join(root, file))
    print(f"Found {len(config_files)} config files.")
    return config_files

def parse_config(file_path):
    print(f"Parsing config file: {file_path}")
    with open(file_path, 'r') as file:
        config = yaml.safe_load(file)
    return config

def check_commit(config):
    if 'fixes' in config:
        for fix in config['fixes']:
            if fix.get('id') == 'DEFAULT_BRANCH' and 'commits' in fix:
                commits = fix['commits']
                if len(commits) == 1:
                    return commits[0]
    return None

def create_directory_structure(vulnerability_id):
    base_dir = os.path.join('data', vulnerability_id)
    before_dir = os.path.join(base_dir, 'before')
    after_dir = os.path.join(base_dir, 'after')
    os.makedirs(before_dir, exist_ok=True)
    os.makedirs(after_dir, exist_ok=True)
    print(f"Created directory structure for {vulnerability_id}")
    return before_dir, after_dir

def clone_repository(repository_url, local_path):
    if not os.path.exists(local_path):
        print(f"Cloning repository: {repository_url} to {local_path}")
        command = f'git clone {repository_url} {local_path}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"Failed to clone repository: {result.stderr}")
    else:
        print(f"Repository already exists at {local_path}")

def get_commit_files(commit, local_path):
    commit_id = commit['id']
    print(f"Getting commit files for commit ID: {commit_id}")

    # Get the list of changed files
    command = f'git show --name-only --pretty=format: {commit_id}'
    result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
    if result.returncode != 0:
        raise Exception(f"Failed to get commit files: {result.stderr}")

    lines = result.stdout.splitlines()
    files = [line.strip() for line in lines if line.strip()]

    return files

def save_files(files, before_dir, after_dir, local_path, commit_id):
    for file in files:
        before_file_path = os.path.join(before_dir, file)
        after_file_path = os.path.join(after_dir, file)

        # Ensure the directory structure exists
        os.makedirs(os.path.dirname(before_file_path), exist_ok=True)
        os.makedirs(os.path.dirname(after_file_path), exist_ok=True)

        # Get the file content before the commit
        command = f'git show {commit_id}^:{file}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
        if result.returncode == 0:
            with open(before_file_path, 'w') as f:
                f.write(result.stdout)
            print(f"Saved before file: {before_file_path}")

        # Get the file content after the commit
        command = f'git show {commit_id}:{file}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
        if result.returncode == 0:
            with open(after_file_path, 'w') as f:
                f.write(result.stdout)
            print(f"Saved after file: {after_file_path}")

def process_config(config, local_path):
    vulnerability_id = config.get('vulnerability_id')
    commit = check_commit(config)

    if commit:
        before_dir, after_dir = create_directory_structure(vulnerability_id)
        files = get_commit_files(commit, local_path)
        save_files(files, before_dir, after_dir, local_path, commit['id'])
        print(f"Files saved successfully for {vulnerability_id}")
    else:
        print(f"No matching commit found for {vulnerability_id}")

def load_task_state():
    if os.path.exists(TASK_STATE_FILE):
        with open(TASK_STATE_FILE, 'r') as file:
            return json.load(file)
    return {}

def save_task_state(task_state):
    with open(TASK_STATE_FILE, 'w') as file:
        json.dump(task_state, file, indent=4)

def is_svn_repository(repository_url):
    return repository_url.startswith('http://') or repository_url.startswith('https://') and 'svn' in repository_url

def main(base_dir):
    task_state = load_task_state()
    config_file_paths = find_config_files(base_dir)
    repositories = {}

    # Collect all repositories
    for config_file_path in config_file_paths:
        if config_file_path not in task_state or not task_state[config_file_path].get('completed', False):
            config = parse_config(config_file_path)
            commit = check_commit(config)
            if commit:
                repository_url = commit['repository']
                if not is_svn_repository(repository_url):
                    repositories[repository_url] = repositories.get(repository_url, []) + [config_file_path]

    # Clone repositories and process configurations
    for repository_url, config_file_paths in repositories.items():
        local_path = os.path.join('repos', repository_url.split('/')[-1].replace('.git', ''))
        try:
            print("clone repo:", repository_url)
            clone_repository(repository_url, local_path)
        except Exception as e:
            print(f"Error cloning repository {repository_url}: {e}")
            for config_file_path in config_file_paths:
                task_state[config_file_path] = {'completed': False, 'error': str(e)}
            save_task_state(task_state)
            continue

        for config_file_path in config_file_paths:
            try:
                config = parse_config(config_file_path)
                process_config(config, local_path)
                task_state[config_file_path] = {'completed': True}
            except Exception as e:
                print(f"Error processing {config_file_path}: {e}")
                task_state[config_file_path] = {'completed': False, 'error': str(e)}

        # Delete the local repository after processing
        print(f"Deleting local repository: {local_path}")
        try:
            shutil.rmtree(local_path)
        except Exception:
            pass

    save_task_state(task_state)

if __name__ == "__main__":
    base_dir = 'project-kb/statements'
    main(base_dir)
