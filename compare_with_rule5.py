import os
import json
import openai
from datetime import datetime
import logging
import re

def setup_logging(context):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"security_analysis_cwe_{context}_{timestamp}.log"
    
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.INFO)
    
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def call_llm(messages):
    try:
        client = openai.OpenAI(
            api_key=os.environ["OPENAI_API_KEY"],
            base_url=os.environ["OPENAI_API_BASE"]
        )
        response = client.chat.completions.create(
            model="claude-3-5-sonnet",
            messages=messages
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"Exception in call_llm: {str(e)}")
        return None

def parse_json(response):
    try:
        if response.find("```json") >= 0:
            start_pos = response.find("```json") + 7
            end_pos = response.rfind("```")
            response = response[start_pos:end_pos]
        else:
            start_pos = response.find("{")
            end_pos = response.rfind("}")
            response = response[start_pos:end_pos+1]
        return json.loads(response, strict=False)
    except Exception as e:
        print("Exception:", str(e))
        raise e

def analyze_before_code(code_path):
    with open(code_path, 'r', encoding='utf-8') as file:
        code = file.read()
    
    prompt = f"""Analyze the following code for potential security risks based on the entire CWE (Common Weakness Enumeration) ruleset:

Code:
{code}

Instructions:
1. Carefully examine the code for any violations of CWE rules.
2. Consider the full context of the code, including potential security measures already in place.
3. Be aware that using environment variables for storing sensitive information is generally considered secure.
4. Only report violations if you are highly confident they exist and are not false positives.
5. If you find any violations, provide the following information for each:
   a. The CWE identifier (e.g., CWE-79)
   b. The name of the CWE
   c. A clear explanation of how the code violates this CWE, including the specific lines of code involved
   d. A suggested mitigation strategy

Provide the output in the following JSON format:

{{
    "risks": [
        {{
            "cwe_id": "CWE-XXX",
            "cwe_name": "Name of the CWE",
            "explanation": "How the code violates this CWE, including line numbers",
            "mitigation": "Suggested mitigation strategy",
            "severity": "high/medium/low",
            "confidence": "high"
        }}
    ]
}}

If no highly relevant and certain risk is found, return an empty list for "risks". Only include risks that you are very confident about and have strong evidence for in the code.
"""
    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def analyze_after_code(code_path, before_risks):
    with open(code_path, 'r', encoding='utf-8') as file:
        code = file.read()
    
    prompt = f"""Given the following code and the previously identified security risks:

Previously identified risks:
{before_risks}

Code to analyze:
{code}

Please check if the previously identified security risks still exist in this code. For each risk, state whether it has been fully addressed or still exists. Provide a brief explanation for each.

Output the result in the following JSON format:

{{
    "after_analysis": {{
        "risk1": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }}
    }},
    "overall_assessment": "overall security improvement assessment"
}}
"""

    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def get_all_files(directory):
    file_list = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_list.append(os.path.relpath(os.path.join(root, file), directory))
    return file_list

def process_case(case_path, logger):
    before_path = os.path.join(case_path, 'before')
    after_path = os.path.join(case_path, 'after')
    
    before_file = get_all_files(before_path)[0]
    after_file = get_all_files(after_path)[0]
    
    before_code_path = os.path.join(before_path, before_file)
    after_code_path = os.path.join(after_path, after_file)

    logger.info(f"Processing case: {case_path}")

    # Step 1: Analyze before code
    logger.info("Analyzing before code...")
    before_analysis = analyze_before_code(before_code_path)
    logger.info(f"Before analysis result:\n{before_analysis}")

    before_risks = parse_json(before_analysis)

    # Check if any risks were identified
    if not before_risks["risks"]:
        logger.info("No risks found. Skipping after code analysis.")
        return {
            "before_risks": [],
            "after_analysis": {},
            "overall_assessment": "No significant risks were identified after careful analysis."
        }

    # Step 2: Analyze after code (only if risks were found in before code)
    logger.info("Analyzing after code...")
    after_analysis = analyze_after_code(after_code_path, json.dumps(before_risks, indent=2))
    logger.info(f"After analysis result:\n{after_analysis}")

    after_result = parse_json(after_analysis)

    # Combine results
    final_result = {
        "before_risks": before_risks["risks"],
        "after_analysis": after_result["after_analysis"],
        "overall_assessment": after_result["overall_assessment"]
    }

    logger.info(f"Final result:\n{json.dumps(final_result, indent=2)}")

    return final_result

def analyze_final_result(final_result):
    remaining_risks = 0
    for risk in final_result['after_analysis'].values():
        if risk['status'] == 'still_exists':
            remaining_risks += 1
    return remaining_risks

def main():
    logger = setup_logging("main")
    logger.info("Starting improved security analysis process based on entire CWE ruleset")

    with open('small_file_cases.json', 'r') as f:
        cases = json.load(f)

    results = {}
    total_cases = 0
    improved_cases = 0
    total_risks = 0
    fixed_risks = 0
    
    for case in cases:
        try:
            case_result = process_case(case, logger)
            results[case] = case_result
            
            # 分析最终结果
            initial_risks = len(case_result['before_risks'])
            remaining_risks = analyze_final_result(case_result) if 'after_analysis' in case_result else 0
            fixed_risks_in_case = initial_risks - remaining_risks
            
            logger.info(f"Case {case}: {remaining_risks} out of {initial_risks} risks still exist")
            
            # 更新计数器
            total_cases += 1
            total_risks += initial_risks
            fixed_risks += fixed_risks_in_case
            
            if initial_risks > 0 and remaining_risks < initial_risks:
                improved_cases += 1
            
            # 将剩余风险数添加到结果中
            results[case]['remaining_risks'] = remaining_risks
            
            # 输出当前统计信息
            logger.info(f"Total cases executed: {total_cases}")
            logger.info(f"Cases with improvements: {improved_cases}")
            logger.info(f"Total risks identified: {total_risks}")
            logger.info(f"Total risks fixed: {fixed_risks}")
            
        except Exception as e:
            logger.error(f"Error processing case {case}: {str(e)}")

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    result_filename = f"security_analysis_cwe_results_{timestamp}.json"
    with open(result_filename, 'w') as f:
        json.dump(results, f, indent=4)

    logger.info("Improved security analysis process based on entire CWE ruleset completed")

if __name__ == "__main__":
    main()