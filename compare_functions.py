import os
import json
import openai
from datetime import datetime
import logging
import re

def setup_logging():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"security_analysis_{timestamp}.log"
    
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.INFO)
    
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def call_llm(messages):
    try:
        client = openai.OpenAI(
            api_key=os.environ["OPENAI_API_KEY"],
            base_url=os.environ["OPENAI_API_BASE"]
        )
        response = client.chat.completions.create(
            model="claude-3-5-sonnet",
            messages=messages
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"Exception in call_llm: {str(e)}")
        return None

def parse_json(response):
    try:
        if response.find("```json") >= 0:
            start_pos = response.find("```json") + 7
            end_pos = response.rfind("```")
            response = response[start_pos:end_pos]
        else:
            start_pos = response.find("{")
            end_pos = response.rfind("}")
            response = response[start_pos:end_pos+1]
        return json.loads(response, strict=False)
    except Exception as e:
        print("Exception:", str(e))
        raise e

def get_all_files(directory):
    file_list = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_list.append(os.path.relpath(os.path.join(root, file), directory))
    return file_list

def analyze_before_code(before_functions, before_full_code):
    prompt = f"""Please analyze the following function code and identify exactly 3 most severe security risks. Consider the context of the full file implementation:

Function code:
{before_functions}

Full file implementation:
{before_full_code}

List exactly 3 security risks, no more and no less:"""
    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def analyze_after_code(after_full_code, before_risks):
    prompt = f"""Given the following code and the previously identified security risks:

Previously identified risks:
{before_risks}

Code to analyze:
{after_full_code}

Please check if the previously identified security risks still exist in this code. For each risk, state whether it has been fully addressed or still exists. Do not use 'partially addressed'. Provide a brief explanation for each:"""

    messages = [{"role": "user", "content": prompt}]
    return call_llm(messages)

def process_case(case_path, logger):
    before_path = os.path.join(case_path, 'before')
    after_path = os.path.join(case_path, 'after')
    
    before_file = get_all_files(before_path)[0]
    after_file = get_all_files(after_path)[0]
    
    before_code_path = os.path.join(before_path, before_file)
    after_code_path = os.path.join(after_path, after_file)

    logger.info(f"Processing case: {case_path}")

    # Read the full before code
    with open(before_code_path, 'r', encoding='utf-8') as file:
        before_full_code = file.read()

    # Read the full after code
    with open(after_code_path, 'r', encoding='utf-8') as file:
        after_full_code = file.read()

    # Read the diff analysis result to get the modified functions
    diff_analysis_path = os.path.join(case_path, 'diff_analysis_result.json')
    with open(diff_analysis_path, 'r') as file:
        diff_analysis = json.load(file)
    
    before_functions = diff_analysis['before_functions']

    # Step 1 & 2: Analyze before code and log results
    logger.info("Analyzing before code...")
    before_analysis = analyze_before_code(before_functions, before_full_code)
    logger.info(f"Before analysis result:\n{before_analysis}")

    # Step 3: Analyze after code
    logger.info("Analyzing after code...")
    after_analysis = analyze_after_code(after_full_code, before_analysis)
    logger.info(f"After analysis result:\n{after_analysis}")

    # Step 4: Generate final JSON output
    final_prompt = f"""Based on the following analyses, please generate a JSON output summarizing the findings:

Before code analysis:
{before_analysis}

After code analysis:
{after_analysis}

Generate a JSON with the following structure:
{{
    "before_risks": [list of identified risks],
    "after_analysis": {{
        "risk1": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }},
        "risk2": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }},
        "risk3": {{
            "status": "addressed/still_exists",
            "explanation": "brief explanation"
        }}
    }},
    "overall_assessment": "overall security improvement assessment"
}}
"""
    messages = [{"role": "user", "content": final_prompt}]
    final_result = call_llm(messages)
    final_result = parse_json(final_result)
    print("final json result:", final_result)
    if not final_result:
        logger.error(f"Final JSON result:\n{final_result}")
    logger.info(f"Final JSON result:\n{final_result}")

    return final_result

def analyze_final_result(final_result):
    remaining_risks = 0
    for risk in final_result['after_analysis'].values():
        if risk['status'] == 'still_exists':
            remaining_risks += 1
    return remaining_risks

def main():
    logger = setup_logging()
    logger.info("Starting security analysis process")

    with open('small_file_cases.json', 'r') as f:
        cases = json.load(f)

    results = {}
    total_cases = 0
    fixed_cases = 0
    
    for case in cases:
        try:
            case_result = process_case(case, logger)
            results[case] = case_result
            
            # 分析最终结果
            remaining_risks = analyze_final_result(case_result)
            logger.info(f"Case {case}: {remaining_risks} out of 3 risks still exist")
            
            # 更新计数器
            total_cases += 1
            if remaining_risks < 3:
                fixed_cases += 1
            
            # 将剩余风险数添加到结果中
            results[case]['remaining_risks'] = remaining_risks
            
            # 输出当前总执行用例数和存在问题被修复的用例数
            logger.info(f"Total cases executed: {total_cases}, Cases with all risks fixed: {fixed_cases}")
            
        except Exception as e:
            logger.error(f"Error processing case {case}: {str(e)}")

    with open('security_analysis_functions_results.json', 'w') as f:
        json.dump(results, f, indent=4)

    logger.info("Security analysis process completed")

if __name__ == "__main__":
    main()