import os
import yaml
import subprocess

def parse_config(file_path):
    with open(file_path, 'r') as file:
        config = yaml.safe_load(file)
    return config

def check_commit(config):
    if 'fixes' in config:
        for fix in config['fixes']:
            if fix.get('id') == 'DEFAULT_BRANCH' and 'commits' in fix:
                commits = fix['commits']
                if len(commits) == 1:
                    return commits[0]
    return None

def create_directory_structure(vulnerability_id):
    base_dir = vulnerability_id
    before_dir = os.path.join(base_dir, 'before')
    after_dir = os.path.join(base_dir, 'after')
    os.makedirs(before_dir, exist_ok=True)
    os.makedirs(after_dir, exist_ok=True)
    return before_dir, after_dir

def clone_repository(repository_url, local_path):
    if not os.path.exists(local_path):
        command = f'git clone {repository_url} {local_path}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"Failed to clone repository: {result.stderr}")
    else:
        print(f"Repository already exists at {local_path}")

def get_commit_files(commit, local_path):
    commit_id = commit['id']

    # Get the list of changed files
    command = f'git show --name-only --pretty=format: {commit_id}'
    result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
    if result.returncode != 0:
        raise Exception(f"Failed to get commit files: {result.stderr}")

    lines = result.stdout.splitlines()
    files = [line.strip() for line in lines if line.strip()]

    return files

def save_files(files, before_dir, after_dir, local_path, commit_id):
    for file in files:
        before_file_path = os.path.join(before_dir, file)
        after_file_path = os.path.join(after_dir, file)

        # Ensure the directory structure exists
        os.makedirs(os.path.dirname(before_file_path), exist_ok=True)
        os.makedirs(os.path.dirname(after_file_path), exist_ok=True)

        # Get the file content before the commit
        command = f'git show {commit_id}^:{file}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
        if result.returncode == 0:
            with open(before_file_path, 'w') as f:
                f.write(result.stdout)

        # Get the file content after the commit
        command = f'git show {commit_id}:{file}'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=local_path)
        if result.returncode == 0:
            with open(after_file_path, 'w') as f:
                f.write(result.stdout)

def main(config_file_path):
    config = parse_config(config_file_path)
    vulnerability_id = config.get('vulnerability_id')
    commit = check_commit(config)

    if commit:
        repository_url = commit['repository']
        local_path = os.path.join(vulnerability_id, 'repo')
        clone_repository(repository_url, local_path)

        before_dir, after_dir = create_directory_structure(vulnerability_id)
        files = get_commit_files(commit, local_path)
        save_files(files, before_dir, after_dir, local_path, commit['id'])
        print(f"Files saved successfully for {vulnerability_id}")
    else:
        print("No matching commit found.")

if __name__ == "__main__":
    config_file_path = './config.yaml'
    main(config_file_path)
